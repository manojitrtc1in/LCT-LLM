#include <stdio.h>
#include <stdlib.h>

#define ll long long
#define REP(i, n) for(ll i=0; i<(n); i++)
#define rep(i, a, b) for(ll i=(a); i<(b); i++)
#define chmax(a, b) if((a) < (b)) (a) = (b)

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    ll first, second;
} P;

typedef struct {
    int size;
    ll* array;
} Array;

typedef struct {
    int size;
    Array* matrix;
} Matrix;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

typedef struct {
    int to, rev;
    ll cap;
} Edge;

typedef struct {
    int size;
    Edge* edges;
} Edges;

typedef struct {
    int size;
    Edges* vertices;
} Graph;

void add_edge(Graph* G, int from, int to, ll cap, int revFlag, ll revCap) {
    Edges* edges = &(G->vertices[from]);
    edges->edges[edges->size].to = to;
    edges->edges[edges->size].cap = cap;
    edges->edges[edges->size].rev = G->vertices[to].size;
    edges->size++;

    if (revFlag) {
        edges = &(G->vertices[to]);
        edges->edges[edges->size].to = from;
        edges->edges[edges->size].cap = revCap;
        edges->edges[edges->size].rev = G->vertices[from].size - 1;
        edges->size++;
    }
}

ll id0(Graph* G, ll v, ll t, ll f, bool* used) {
    if (v == t) {
        return f;
    }
    used[v] = 1;
    for (int i = 0; i < G->vertices[v].size; ++i) {
        Edge* e = &(G->vertices[v].edges[i]);
        if (!used[e->to] && e->cap > 0) {
            ll d = id0(G, e->to, t, (f < e->cap) ? f : e->cap, used);
            if (d > 0) {
                e->cap -= d;
                G->vertices[e->to].edges[e->rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

ll max_flow(Graph* G, ll s, ll t) {
    ll flow = 0;
    for (;;) {
        bool used[G->size];
        for (int i = 0; i < G->size; ++i) {
            used[i] = 0;
        }
        ll f = id0(G, s, t, 1LL << 62, used);
        if (f == 0) {
            return flow;
        }
        flow += f;
    }
}

void id2(Graph* G, ll s, Array* d, Array* negative) {
    d->size = G->size;
    negative->size = G->size;
    for (int i = 0; i < d->size; ++i) {
        d->array[i] = 1LL << 62;
        negative->array[i] = 0;
    }
    d->array[s] = 0;
    for (int k = 0; k < G->size - 1; ++k) {
        for (int i = 0; i < G->size; ++i) {
            for (int j = 0; j < G->vertices[i].size; ++j) {
                Edge* e = &(G->vertices[i].edges[j]);
                if (d->array[i] != 1LL << 62 && d->array[e->to] > d->array[i] + e->cap) {
                    d->array[e->to] = d->array[i] + e->cap;
                }
            }
        }
    }
    for (int k = 0; k < G->size - 1; ++k) {
        for (int i = 0; i < G->size; ++i) {
            for (int j = 0; j < G->vertices[i].size; ++j) {
                Edge* e = &(G->vertices[i].edges[j]);
                if (d->array[i] != 1LL << 62 && d->array[e->to] > d->array[i] + e->cap) {
                    d->array[e->to] = d->array[i] + e->cap;
                    negative->array[e->to] = 1;
                }
                if (negative->array[i] == 1) {
                    negative->array[e->to] = 1;
                }
            }
        }
    }
}

void Dijkstra(Graph* G, ll s, Array* d) {
    d->size = G->size;
    for (int i = 0; i < d->size; ++i) {
        d->array[i] = 1LL << 62;
    }
    d->array[s] = 0;
    int* used = (int*)malloc(G->size * sizeof(int));
    for (int i = 0; i < G->size; ++i) {
        used[i] = 0;
    }
    P* q = (P*)malloc(G->size * sizeof(P));
    int q_size = 0;
    q[q_size].first = 0;
    q[q_size].second = s;
    q_size++;
    while (q_size > 0) {
        int a = q[0].second;
        q_size--;
        for (int i = 0; i < G->vertices[a].size; ++i) {
            Edge e = G->vertices[a].edges[i];
            if (d->array[e.to] > d->array[a] + e.cap) {
                d->array[e.to] = d->array[a] + e.cap;
                q[q_size].first = d->array[e.to];
                q[q_size].second = e.to;
                q_size++;
            }
        }
    }
    free(q);
    free(used);
}

void id4(Graph* G, Matrix* d) {
    d->size = G->size;
    for (int i = 0; i < d->size; ++i) {
        d->matrix[i].size = G->size;
    }
    for (int i = 0; i < d->size; ++i) {
        for (int j = 0; j < d->matrix[i].size; ++j) {
            d->matrix[i].array[j] = (i != j) ? 1LL << 62 : 0;
        }
    }
    for (int i = 0; i < G->size; ++i) {
        for (int j = 0; j < G->vertices[i].size; ++j) {
            chmin(d->matrix[i].array[G->vertices[i].edges[j].to], G->vertices[i].edges[j].cap);
        }
    }
    for (int i = 0; i < G->size; ++i) {
        for (int j = 0; j < G->size; ++j) {
            for (int k = 0; k < G->size; ++k) {
                chmin(d->matrix[j].array[k], d->matrix[j].array[i] + d->matrix[i].array[k]);
            }
        }
    }
}

int tsort(Graph* graph, Array* order) {
    int n = graph->size, k = 0;
    Array in;
    in.size = n;
    for (int i = 0; i < n; ++i) {
        in.array[i] = 0;
    }
    for (int i = 0; i < graph->size; ++i) {
        for (int j = 0; j < graph->vertices[i].size; ++j) {
            in.array[graph->vertices[i].edges[j].to]++;
        }
    }
    int* que = (int*)malloc(n * sizeof(int));
    int que_size = 0;
    for (int i = 0; i < n; ++i) {
        if (in.array[i] == 0) {
            que[que_size] = i;
            que_size++;
        }
    }
    while (que_size > 0) {
        int v = que[0];
        que_size--;
        order->array[order->size] = v;
        order->size++;
        for (int i = 0; i < graph->vertices[v].size; ++i) {
            Edge e = graph->vertices[v].edges[i];
            in.array[e.to]--;
            if (in.array[e.to] == 0) {
                que[que_size] = e.to;
                que_size++;
            }
        }
    }
    free(que);
    if (order->size != n) {
        return 0;
    }
    else {
        return 1;
    }
}

typedef struct {
    int n;
    int log2_n;
    int** parent;
    int* depth;
} Lca;

Lca* new_Lca(Graph* g, int root) {
    Lca* lca = (Lca*)malloc(sizeof(Lca));
    lca->n = g->size;
    lca->log2_n = log2(lca->n) + 1;
    lca->parent = (int**)malloc(lca->log2_n * sizeof(int*));
    for (int i = 0; i < lca->log2_n; ++i) {
        lca->parent[i] = (int*)malloc(lca->n * sizeof(int));
    }
    lca->depth = (int*)malloc(lca->n * sizeof(int));
    for (int i = 0; i < lca->n; ++i) {
        lca->depth[i] = 0;
    }
    dfs(g, root, -1, 0);
    for (int k = 0; k + 1 < lca->log2_n; ++k) {
        for (int v = 0; v < g->size; ++v) {
            if (lca->parent[k][v] < 0) {
                lca->parent[k + 1][v] = -1;
            }
            else {
                lca->parent[k + 1][v] = lca->parent[k][lca->parent[k][v]];
            }
        }
    }
    return lca;
}

void dfs(Graph* g, int v, int p, int d) {
    lca->parent[0][v] = p;
    lca->depth[v] = d;
    for (int i = 0; i < g->vertices[v].size; ++i) {
        Edge e = g->vertices[v].edges[i];
        if (e.to != p) {
            dfs(g, e.to, v, d + 1);
        }
    }
}

int get(Lca* lca, int u, int v) {
    if (lca->depth[u] > lca->depth[v]) {
        int tmp = u;
        u = v;
        v = tmp;
    }
    for (int k = 0; k < lca->log2_n; ++k) {
        if ((lca->depth[v] - lca->depth[u]) >> k & 1) {
            v = lca->parent[k][v];
        }
    }
    if (u == v) {
        return u;
    }
    for (int k = lca->log2_n - 1; k >= 0; --k) {
        if (lca->parent[k][u] != lca->parent[k][v]) {
            u = lca->parent[k][u];
            v = lca->parent[k][v];
        }
    }
    return lca->parent[0][u];
}

typedef struct {
    int size;
    int* data;
    ll num;
} UnionFind;

UnionFind* new_UnionFind(int size) {
    UnionFind* uf = (UnionFind*)malloc(sizeof(UnionFind));
    uf->size = size;
    uf->data = (int*)malloc(size * sizeof(int));
    for (int i = 0; i < size; ++i) {
        uf->data[i] = -1;
    }
    uf->num = size;
    return uf;
}

int merge(UnionFind* uf, int x, int y) {
    x = root(uf, x);
    y = root(uf, y);
    if (x != y) {
        if (uf->data[y] < uf->data[x]) {
            int tmp = x;
            x = y;
            y = tmp;
        }
        uf->data[x] += uf->data[y];
        uf->data[y] = x;
    }
    uf->num -= (x != y);
    return x != y;
}

int same(UnionFind* uf, int x, int y) {
    return root(uf, x) == root(uf, y);
}

int root(UnionFind* uf, int x) {
    return uf->data[x] < 0 ? x : uf->data[x] = root(uf, uf->data[x]);
}

ll size(UnionFind* uf, int x) {
    return -uf->data[root(uf, x)];
}

ll num(UnionFind* uf) {
    return uf->num;
}

typedef struct {
    int size;
    ll* data;
} SegmentTree;

SegmentTree* new_SegmentTree(int size) {
    SegmentTree* segtree = (SegmentTree*)malloc(sizeof(SegmentTree));
    segtree->size = size;
    segtree->data = (ll*)malloc((2 * size - 1) * sizeof(ll));
    for (int i = 0; i < 2 * size - 1; ++i) {
        segtree->data[i] = 0;
    }
    return segtree;
}

void set_val(SegmentTree* segtree, int i, ll x) {
    i += segtree->size - 1;
    segtree->data[i] = x;
    while (i > 0) {
        i = (i - 1) / 2;
        segtree->data[i] = segtree->data[i * 2 + 1] + segtree->data[i * 2 + 2];
    }
}

ll query(SegmentTree* segtree, int l, int r) {
    ll left = 0, right = 0;
    l += segtree->size - 1;
    r += segtree->size - 1;
    while (l < r) {
        if ((l & 1) == 0) {
            left += segtree->data[l];
        }
        if ((r & 1) == 0) {
            right += segtree->data[r - 1];
        }
        l = l / 2;
        r = (r - 1) / 2;
    }
    return left + right;
}

typedef struct {
    int n;
    ll* data;
    int p;
} id3;

id3* new_id3(int n) {
    id3* id = (id3*)malloc(sizeof(id3));
    id->n = n;
    id->data = (ll*)malloc((n + 1) * sizeof(ll));
    for (int i = 0; i < n + 1; ++i) {
        id->data[i] = 0;
    }
    id->p = 1;
    while (id->p < n + 1) {
        id->p *= 2;
    }
    return id;
}

ll sum(id3* id, int k) {
    ll ret = 0;
    for (; k > 0; k -= k & -k) {
        ret += id->data[k];
    }
    return ret;
}

ll sum(id3* id, int a, int b) {
    return sum(id, b) - sum(id, a);
}

void add(id3* id, int k, ll x) {
    for (++k; k <= id->n; k += k & -k) {
        id->data[k] += x;
    }
}

int lower_bound(id3* id, ll w) {
    if (w <= 0) {
        return -1;
    }
    int x = 0;
    for (int k = id->p / 2; k > 0; k /= 2) {
        if (x + k <= id->n && id->data[x + k] < w) {
            w -= id->data[x + k];
            x += k;
        }
    }
    return x;
}

void divisor(ll n, Array* ret) {
    ret->size = 0;
    for (ll i = 1; i * i <= n; ++i) {
        if (n % i == 0) {
            ret->array[ret->size] = i;
            ret->size++;
            if (i * i != n) {
                ret->array[ret->size] = n / i;
                ret->size++;
            }
        }
    }
    for (int i = 0; i < ret->size; ++i) {
        for (int j = i + 1; j < ret->size; ++j) {
            if (ret->array[i] > ret->array[j]) {
                ll tmp = ret->array[i];
                ret->array[i] = ret->array[j];
                ret->array[j] = tmp;
            }
        }
    }
}

void id5(ll n, Array* ret) {
    ret->size = 0;
    for (ll i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            ret->array[ret->size].first = i;
            ret->array[ret->size].second = 0;
            while (n % i == 0) {
                n /= i;
                ret->array[ret->size].second++;
            }
            ret->size++;
        }
    }
    if (n != 1) {
        ret->array[ret->size].first = n;
        ret->array[ret->size].second = 1;
        ret->size++;
    }
}

ll mod_pow(ll x, ll n, ll mod) {
    ll res = 1;
    while (n > 0) {
        if (n & 1) {
            res = res * x % mod;
        }
        x = x * x % mod;
        n >>= 1;
    }
    return res;
}

ll mod_inv(ll x, ll mod) {
    return mod_pow(x, mod - 2, mod);
}

typedef struct {
    int size;
    ll* fact;
    ll* fact_inv;
    ll mod;
} Combination;

Combination* new_Combination(ll n, ll mod) {
    Combination* comb = (Combination*)malloc(sizeof(Combination));
    comb->size = n;
    comb->mod = mod;
    comb->fact = (ll*)malloc(n * sizeof(ll));
    comb->fact_inv = (ll*)malloc(n * sizeof(ll));
    for (int i = 0; i < n; ++i) {
        comb->fact[i] = 0;
        comb->fact_inv[i] = 0;
    }
    ll m = (n < mod) ? n : mod;
    comb->fact[0] = 1;
    for (int i = 1; i < m; ++i) {
        comb->fact[i] = (comb->fact[i - 1] * i) % mod;
    }
    comb->fact_inv[m - 1] = mod_inv(comb->fact[m - 1], mod);
    for (int i = m - 2; i >= 0; --i) {
        comb->fact_inv[i] = (comb->fact_inv[i + 1] * (i + 1)) % mod;
    }
    return comb;
}

ll nCr(Combination* comb, ll n, ll r) {
    if (n < r) {
        return 0;
    }
    if (n < comb->mod) {
        return ((comb->fact[n] * comb->fact_inv[r]) % comb->mod * comb->fact_inv[n - r]) % comb->mod;
    }
    ll ret = 1;
    while (n || r) {
        ll _n = n % comb->mod, _r = r % comb->mod;
        n /= comb->mod;
        r /= comb->mod;
        (ret *= nCr(comb, _n, _r)) %= comb->mod;
    }
    return ret;
}

ll nPr(Combination* comb, ll n, ll r) {
    return (comb->fact[n] * comb->fact_inv[n - r]) % comb->mod;
}

ll nHr(Combination* comb, ll n, ll r) {
    return nCr(comb, r + n - 1, r);
}

ll popcount(ll x) {
    x = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);
    x = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);
    x = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);
    x = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);
    x = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);
    x = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);
    return x;
}

typedef struct {
    int size;
    ll* data;
    int identity_t;
    int identity_e;
    int (*f_tt)(int, int);
    int (*f_te)(int, int);
    int (*f_ee)(int, int);
    int (*f_ep)(int, int);
} id1;

id1* new_id1(int size, int identity_t, int identity_e, int (*f_tt)(int, int), int (*f_te)(int, int), int (*f_ee)(int, int), int (*f_ep)(int, int)) {
    id1* id = (id1*)malloc(sizeof(id1));
    id->size = size;
    id->identity_t = identity_t;
    id->identity_e = identity_e;
    id->f_tt = f_tt;
    id->f_te = f_te;
    id->f_ee = f_ee;
    id->f_ep = f_ep;
    id->data = (int*)malloc((2 * size - 1) * sizeof(int));
    for (int i = 0; i < 2 * size - 1; ++i) {
        id->data[i] = identity_t;
    }
    return id;
}

void update(id1* id, int a, int b, int x, int k, int l, int r) {
    if (r <= a || b <= l) {
        return;
    }
    if (a <= l && r <= b) {
        id->data[k] = id->f_ee(id->data[k], x);
        return;
    }
    update(id, a, b, x, k * 2 + 1, l, (l + r) / 2);
    update(id, a, b, x, k * 2 + 2, (l + r) / 2, r);
    id->data[k] = id->f_tt(id->data[k * 2 + 1], id->data[k * 2 + 2]);
}

int query(id1* id, int a, int b, int k, int l, int r) {
    if (r <= a || b <= l) {
        return id->identity_t;
    }
    if (a <= l && r <= b) {
        return id->data[k];
    }
    int vl = query(id, a, b, k * 2 + 1, l, (l + r) / 2);
    int vr = query(id, a, b, k * 2 + 2, (l + r) / 2, r);
    return id->f_tt(vl, vr);
}

typedef struct {
    int size;
    ll* data;
    int identity_t;
    int identity_e;
    int (*f_tt)(int, int);
    int (*f_te)(int, int);
    int (*f_ee)(int, int);
    int (*f_ep)(int, int);
} id1;

id1* new_id1(int size, int identity_t, int identity_e, int (*f_tt)(int, int), int (*f_te)(int, int), int (*f_ee)(int, int), int (*f_ep)(int, int)) {
    id1* id = (id1*)malloc(sizeof(id1));
    id->size = size;
    id->identity_t = identity_t;
    id->identity_e = identity_e;
    id->f_tt = f_tt;
    id->f_te = f_te;
    id->f_ee = f_ee;
    id->f_ep = f_ep;
    id->data = (ll*)malloc((2 * size - 1) * sizeof(ll));
    for (int i = 0; i < 2 * size - 1; ++i) {
        id->data[i] = identity_t;
    }
    return id;
}

void update(id1* id, int a, int b, int x, int k, int l, int r) {
    if (r <= a || b <= l) {
        return;
    }
    if (a <= l && r <= b) {
        id->data[k] = id->f_ee(id->data[k], x);
        return;
    }
    update(id, a, b, x, k * 2 + 1, l, (l + r) / 2);
    update(id, a, b, x, k * 2 + 2, (l + r) / 2, r);
    id->data[k] = id->f_tt(id->data[k * 2 + 1], id->data[k * 2 + 2]);
}

ll query(id1* id, int a, int b, int k, int l, int r) {
    if (r <= a || b <= l) {
        return id->identity_t;
    }
    if (a <= l && r <= b) {
        return id->data[k];
    }
