












































































































































___6<___ T,___L>___U ignore_second=T;___6<___L...Ix,___ T>auto id33(___22<Ix...>,___1 T&x){___a ___n(ignore_second<T,Ix>(x)...);}___6<___L n,___ T>auto id31(___1 T&x){___a id33(std::make_index_sequence<n>{},x);}___6<___L n,___ T>___U id7=___3(id31<n,T>(___X<T>()));___6<___...Args>auto id35(___1 ___n<Args...>&t){___a ___G<0>(t);}___6<___L...Ix,___...Args>auto id24(___22<Ix...>,___1 ___n<Args...>&t){___a ___n(___G<Ix+1>(t)...);}___6<___...Args>auto tuple_tail(___1 ___n<Args...>&t){___a id24(std::make_index_sequence<sizeof...(Args)-1>{},t);}___6<___ T1,___ T2>std::common_type_t<T1,T2>maxx(___1 T1&x,___1 T2&y){if(x<y){___a y;}else{___a x;}} ___6<___ T1,___ T2,___...Ts>___P auto maxx(___1 T1&x,___1 T2&y,___1 Ts&...xs){___a maxx(maxx(x,y),xs...);}___6<___ T1,___ T2>auto minn(___1 T1&x,___1 T2&y){if(x<=y){___a x;}else{___a y;}} ___6<___ T1,___ T2,___...Ts>___P auto minn(___1 T1&x,___1 T2&y,___1 Ts&...xs){___a minn(minn(x,y),xs...);}___B int _log2(int x){if(x==0){___a 0;}___a 31^__builtin_clz(x);} 





























___6<___ F>class ___1Z{___S:F f;___k:___1Z(F f_):f(f_){} ___6<___...Ts>___B ___3(auto)___l()(Ts&&...xs)___1{___a f(___T<Ts>(xs)...);}};___1Z _(FF(x,x));___1Z _1(FF(x,y,x));___1Z _2(FF(x,y,y));


___1L(+)___1L(-)___1L(!)___1L(~)___1L(*)___1L(&)___9(+)___9(-)___9(*)___9(/)___9(%)___9(<)___9(>)___9(<=)___9(>=)___9(==)___9(!=)___9(<<)___9(>>)___9(&)___9(|)___9(^)___9(&&)














___6<___ T,___=void>___C is_iterable:___k std::false_type{};___6<___ T>___C is_iterable<T,std::void_t<___3(___z(___X<T>())),___3(___5(___X<T>()))>>:___k std::true_type{};___6<___ T>___B bool id19=is_iterable<T>::value;___6<___ T,___=void>___C is_composable:___k std::false_type{};___6<___ T>___C is_composable<T,std::void_t<___ T::is_composable_>>:___k std::true_type{};___6<___ T>___B bool id21=is_composable<T>::value;___6<___ T,___=___1C<id19<T>>>___C correct_iterator{___U type=std::conditional_t<std::is_const_v<___12<T>>,___ ___12<T>::const_iterator,___ ___12<T>id36>;};___6<___ T>___U id17=___ correct_iterator<T>::type;___6<___ I>___P auto ___j(___1 I&b,___1 I&e){___C Wrapper{ 

___U id40=void;___U ___f=I;___U const_iterator=I;___U value_type=___p<___3(*___X<I>())>;

I b,e;auto begin()___1{___a b;}auto end()___1{___a e;}};___a Wrapper{b,e};}___e(T)___P auto iter(T&&iterable){___a ___j(___z(iterable),___5(iterable));}___6<___ C>___C ___1I:___k C::iterator{___19<C>p;___1I(___19<C>p_,___ C::iterator it):C::iterator(it),p(p_){}};___6<___ C>___P auto iterc(C&&v){___U D=___p<C>;___19<D>p(new D(___T<C>(v)));___a ___j(___1I<D>{p,___z(*p)},___1I<D>{p,___5(*p)});}___6<___ T>___P auto iter(std::initializer_list<T>l){___a iterc(___A<T>(l));}___6<___ T,___ F,___=___1q<F,T>>___3(auto)___l>(T&&v,___1 F&f){___a f(___T<T>(v));}___6<___ M1,___ M2>___C composed{___U id27=void;___1 M1 m1;___1 M2 m2;___6<___ T>___3(auto)___l()(T&&v)___1{___a m1(m2(___T<T>(v)));}};___6<___ M1,___ M2,___=___1C<id21<M1>or id21<M2>>>___P auto ___l<(___1 M1&m1,___1 M2&m2){___a composed<M1,M2>{m1,m2};} 

to_container_macro(vector,push_back)to_container_macro(set,insert)to_container_macro(unordered_set,insert)___6<___L n>___C ___1d{___e(T)___P ___D auto make(T&&v){___a ___T<T>(v)>apply(FF(u,___1d<n-1>::make(u)))>___1A;}___e(T)___P ___D auto make(___1 T&v){___a ___T<T>(v)>apply(FF(u,___1d<n-1>::make(u)))>___1A;}};___6<>___C ___1d<1>{___e(T)___P ___D auto make(T&&v){___a ___T<T>(v)>___1A;}___e(T)___P ___D auto make(___1 T&v){___a ___T<T>(v)>___1A;}};___6<___L n>___C to_nested_vector_{___U id27=void;___e(T)___P ___3(auto)___l()(T&&v)___1{___a ___1d<n>::make(___T<T>(v));}};___6<___L n>to_nested_vector_<n>to_nested_vector;def_iterator_manip(array_slice,,(size_t l,size_t r),({l,r}),___L l;___L r;,{___a ___j(___z(v)+l,___z(v)+r);})def_iterator_manip(is_nil,{return not(std::begin(v)!=___5(v));});def_iterator_manip(length,{size_t l=0;for(auto&i:v){++l;}___a l;});

___6<___ T1,___ T2,___ T3,___ T=___1D<___3(T1()+T2()+T3())>>___P auto range(___1 T1&b,___1 T2&e,___1 T3&step){id41(T x;T e;T step;bool ___y()___1{___a(step>=T(0)and x>=e)or(step<T(0)and x<=e);},___y()xor ___x.___y(),{x+=step;},T(x))___a ___j(___O{b,e,step},___O{e,e,step});}___6<___ T1,___ T2>___P auto range(___1 T1&b,___1 T2&e){___a range(b,e,1);}___6<___ T>___P auto range(___1 T&e){___a range(T(),e,1);} 

___6<___ T>___P auto to_infinity(___1 T&b=T(),___1 T&step=1){id41(T x;T step;,true,{x+=step;},T(x))___a ___j(___O{b,step},___O{b,step});}___11(apply,___6<___ F>,(F f),<F>{f},F f;,(___O{f,___z(v)}),(___O{f,___5(v)}),,it!=___x.it,{++it;},f(*it))___11(take,,(___L n),{n},___L n;,(___O{n,___z(v)}),(___O{0,___5(v)}),,n!=___x.n,{--n;if(n>0){++it;}},*it)___11(take_while,___6<___ F>,(F f),<F>{f},F f;,(___O{f,not(___z(v)!=___5(v)and f(*___z(v))),___z(v)}),(___O{f,true,___5(v)}),bool ___y;,___y xor ___x.___y,{++it;if(not f(*it)){___y=true;}},*it)___11(drop,,(___L n),{n},___r ___L n;,(___O{n,___5(v),___z(v)}),(___O{0,___5(v),___5(v)}),___1 I end_it;___P void ___F()___1{while(n>0){if(not(it!=end_it)){n=0;break;}--n;++it;}},(___F(),___x.___F(),it!=___x.it),{___F();++it;},(___F(),*it))___11(drop_while,___6<___ F>,(F f),<F>{f},F f;,(___O{f,___5(v),false,___z(v)}),(___O{f,___5(v),true,___5(v)}),___1 I end_it;___r bool id6;___P void ___F()___1{if(not id6){while(it!=end_it and f(*it)){++it;}id6=true;}},(___F(),___x.___F(),it!=___x.it),{___F();++it;},(___F(),*it))def_iterator_manip(head,{return*std::begin(v);})___P auto tail=drop(1);___P auto at(___L n){___a head<drop(n);}___11(cons,___6<___ S>,(S s),<S>{s},S s;,(___O{s,true,___z(v)}),(___O{s,false,___5(v)}),bool is_s;,is_s!=___x.is_s or it!=___x.it,{if(is_s){is_s=false;}else{++it;}},(is_s)?(s):(*it))def_iterator_manip(snoc,{auto it=std::begin(v);auto h=*it;++it;___a ___n(h,___j(it,___5(v)));})def_iterator_manip(split_at,,(size_t n),{n},___L n;,{auto it=___z(v);___A<T>u;for(auto i:range(n)){u.___1_(*it);++it;}___a ___n(iterc(std::move(u)),___j(it,___5(v)));})

___11(chunks_of,,(___L n),{n},___L n;,(___O{n,{},false,___5(v),___z(v)}),(___O{n,{},false,___5(v),___5(v)}),___r ___A<V>u;___r bool ___K;I it_end;void update()___1{u.clear();___K=true;for(auto i:range(n)){if(it!=it_end){u.___1_(*it);++it;}else{break;}}},it!=___x.it,{if(___K){___K=false;}else{for(auto i:range(n)){if(it!=it_end){++it;}else{break;}}}},(___K)?(iterc(u)):(update(),iterc(u))) 

___6<___ F,___ S>___C fold_impl{___U id27=void;F f;S s;___e(T)___3(auto)___l()(___1 T&v)___1{auto x=s;for(auto y:v){x=f(x,y);}___a x;}};___6<___ F,___ S>___P auto fold(F f,___1 S&s){___a fold_impl<F,S>{f,s};}def_iterator_manip(fold1,template<typename F>,(F f),<F>{f},F f;,{auto u=v>snoc;___a ___G<1>(u)>fold(f,___G<0>(u));})def_iterator_manip(sum,{return v>fold(std::plus<V>(),V());})def_iterator_manip(product,{return v>fold(std::multiplies<V>(),V(1));})def_iterator_manip(maximum_by,template<typename F>,(F f),<F>{f},F f;,{___a v>fold1(FF(x,y,(f(x,y))?(y):(x)));})def_iterator_manip(maximum,{return v>maximum_by(std::less<V>());})def_iterator_manip(maximum_on,template<typename F>,(F f),<F>{f},F f;,{___a v>fold1(FF(x,y,(f(x)<f(y))?(y):(x)));})def_iterator_manip(minimum_by,template<typename F>,(F f),<F>{f},F f;,{___a v>fold1(FF(x,y,(f(y,x))?(y):(x)));})def_iterator_manip(minimum,{return v>minimum_by(std::less<V>());})def_iterator_manip(minimum_on,template<typename F>,(F f),<F>{f},F f;,{___a v>fold1(FF(x,y,(f(y)<f(x))?(y):(x)));})___6<___ F,___ S>___C scan_impl{___U id27=void;F f;S s;___e(T,I)___3(auto)___l()(___1 T&v)___1{id41(F f;___r S s;___r bool ___K;bool id6;___r I it;,it!=___x.it,{if(not ___K){s=f(s,*it);};___K=false;if(id6){++it;}else{id6=true;}},(___K)?(s):(___K=true,s=f(s,*it)))___a ___j(___O{f,s,true,false,___z(v)},___O{f,s,true,true,___5(v)});}___e(T,I)___3(auto)___l()(T&v)___1{id41(F f;___r S s;___r bool ___K;bool id6;___r I it;,it!=___x.it,{if(not ___K){s=f(s,*it);};___K=false;if(id6){++it;}else{id6=true;}},(___K)?(s):(___K=true,s=f(s,*it)))___a ___j(___O{f,s,true,false,___z(v)},___O{f,s,true,true,___5(v)});}};___6<___ F,___ S>___P auto scan(F f,___1 S&s){___a scan_impl<F,S>{f,s};}___11(scan1,___6<___ F>,(F f),<F>{f},F f;,(___O{f,*___z(v),true,___z(v)}),(___O{f,*___z(v),true,___5(v)}),___r V s;___r bool ___K;,it!=___x.it,{if(not ___K){s=f(s,*it);};___K=false;++it;},(___K)?(s):(___K=true,s=f(s,*it)))___6<___ T,___ S,___ I=id17<T>,___ J=id17<S>>___P auto ___l+(T&&v,S&&u){id41(I i;I i_end;J j;bool in_i;,i!=___x.i or j!=___x.j,{if(in_i){++i;if(not(i!=i_end)){in_i=false;}}else{++j;}},(in_i)?(*i):(*j))I bv=___z(v);I ev=___5(v);J bu=___z(u);J eu=___5(u);___a ___j(___O{bv,ev,bu,bv!=ev},___O{ev,ev,eu,false});}___B ___C{___U id27=void;___e(T)auto ___l()(T&&v)___1{auto u=___T<T>(v)>filter(FF(i,not is_nil(i)));auto b=___z(u);auto e=___5(u);___U J=___3(b);___U V=___p<___3(*b)>;___U K=___3(___z(*b));___C ___O{J j;J j_end;___19<V>id1;K*k_ptr;bool ___y;___O(J j,J j_end,___1 V&jv,bool ___y):j(j),j_end(j_end),id1(new V(jv)),k_ptr(new K(___z(*id1))),___y(___y){} ___O(J j,J j_end,bool ___y):j(j),j_end(j_end),id1(nullptr),k_ptr(nullptr),___y(___y){} ___O(___1 ___O&___x):j(___x.j),j_end(___x.j_end),id1(___x.id1),k_ptr((___x.k_ptr)?(new K(*___x.k_ptr)):nullptr),___y(___x.___y){} ___O(___O&&___x):j(___x.j),j_end(___x.j_end),id1(___x.id1),k_ptr((___x.k_ptr)?(new K(*___x.k_ptr)):nullptr),___y(___x.___y){}~___O(){delete k_ptr;}bool ___l!=(___1 ___O&___x)___1{___a ___y xor ___x.___y;}void ___l++(){++*k_ptr;if(not(*k_ptr!=___5(*id1))){++j;if(j!=j_end){delete k_ptr;id1=std::make_shared<V>(*j);k_ptr=new K(___z(*id1));}else{___y=true;}}}___3(auto)___l*()___1{___a**k_ptr;}};if(u>is_nil){___a ___j(___O(b,e,true),___O(b,e,true));}else{___a ___j(___O(b,e,*b,false),___O(e,e,true));}}}flatten;___6<___ T,___ F,___=___1C<id19<T>>>auto ___l>=(___1 T&v,F f){___a v>apply(f)>flatten;}___6<___ U,___L i,___L s>bool id8(___1 U&x,___1 U&y){if ___B(i<s){___a ___G<i>(x)!=___G<i>(y)and id8<U,i+1,s>(x,y);}else{___a true;}} ___6<___ U,___L i,___L s>void id9(U&u){if ___B(i<s){++___G<i>(u);id9<U,i+1,s>(u);}} ___6<___ F,___...Args,___L...Seq>___3(auto)id20(F f,___1 ___n<Args...>&u,___22<Seq...>){___a f(*___G<Seq>(u)...);}___6<___ F,___...Ts>___P auto zip_with(F f,Ts&&...vs){id41(F f;___n<id17<Ts>...>its;,(id8<___3(its),0,sizeof...(Ts)>(its,___x.its)),{(id9<___3(its),0,sizeof...(Ts)>(its));},id20(f,its,___1r<Ts...>{}))___a ___j(___O{f,___n<id17<Ts>...>(___z(vs)...)},___O{f,___n<id17<Ts>...>(___5(vs)...)});}___C zip_default_function_{___6<___...Ts>___3(auto)___l()(Ts&&...xs)___1{___a ___n<Ts...>(xs...);}};___6<___...Ts>___P auto zip(Ts&&...vs){___a zip_with(zip_default_function_{},___T<Ts>(vs)...);}___11(filter,___6<___ F>,(F f),<F>{f},F f;,(___O{f,___5(v),___z(v)}),(___O{f,___5(v),___5(v)}),___1 I end_it;___P void ___F()___1{while(it!=end_it and not f(*it)){++it;}},(___F(),___x.___F(),it!=___x.it),{___F();++it;},(___F(),*it))def_template_lambda(___6<___ T>,repeat,(T&&v),{___C ___O{___1 ___p<T>v;bool ___l!=(___1 ___O&)___1{___a true;}void ___l++(){} ___1 auto&___l*()___1{___a v;}};___a ___j(___O{v},___O{v});})___P auto replicate(___L n){___a take(n)<repeat;}___P auto cycle=flatten<repeat;def_iterator_manip(enumerate,{return zip(to_infinity(size_t(0)),v);})def_iterator_manip(reversed,{auto s=v>to_vector;std::reverse(s.begin(),s.end());___a iterc(std::move(s));})def_iterator_manip(sorted_by,template<typename F>,(F f),<F>{f},F f;,{auto s=v>___1A;std::sort(___z(s),___5(s),f);___a iterc(std::move(s));})def_iterator_manip(sorted,{return v>sorted_by(std::less<V>());})def_iterator_manip(sorted_on,template<typename F>,(F f),<F>{f},F f;,{___a v>apply(FF(i,___n(i,f(i))))>sorted_by(FF(x,y,___G<1>(x)<___G<1>(y)))>apply(FF(i,___G<0>(i)));})def_iterator_manip(nub,{iterator_macro(I it_end;I it;,it!=other.it,{decltype(*it)pr;do{pr=*it;++it;}while(it!=it_end and pr==*it);},*it)auto b=___z(v);auto e=___5(v);___a ___j(___O{e,b},___O{e,e});})___6<___ F,___ S>___C accum_vector_by_{___U id27=void;___L n;F f;S s;___e(T,I,V)___3(auto)___l()(___1 T&v)___1{___A<___p<___1q<F,S,___3(___G<1>(___X<V>()))>>>u(n,s);for(auto&&[i,x]:v){u[i]=f(u[i],x);}___a u;}};___6<___ F,___ S>___P auto id2(___L n,F f,___1 S&s){___a accum_vector_by_<F,S>{n,f,s};}___6<___ S>___P auto id18(___L n,___1 S&s=S()){___a id2(n,_2,s);}___6<___ F,___ S>___C accum_map_by_{___U id27=void;F f;S s;___e(T,I,V)___3(auto)___l()(___1 T&v)___1{std::map<___p<___3(___G<0>(___X<V>()))>,___p<___1q<F,S,___3(___G<1>(___X<V>()))>>>u;for(auto&&[i,x]:v){if(u.count(i)){u[i]=f(u[i],x);}else{u[i]=f(s,x);}} ___a u;}};___6<___ F,___ S>___P auto id30(F f,___1 S&s){___a accum_map_by_<F,S>{f,s};}___6<___ S>___P auto id13(___1 S&s=S()){___a id30(_2,s);}___6<___ F,___ S>___C accum_unordered_map_by_{___U id27=void;F f;S s;___e(T,I,V)___3(auto)___l()(___1 T&v)___1{std::unordered_map<___p<___3(___G<0>(___X<V>()))>,___p<___1q<F,S,___3(___G<1>(___X<V>()))>>>u;for(auto&&[i,x]:v){if(u.count(i)){u[i]=f(u[i],x);}else{u[i]=f(s,x);}} ___a u;}};___6<___ F,___ S>___P auto id26(F f,___1 S&s){___a accum_unordered_map_by_<F,S>{f,s};}___6<___ S>___P auto id15(___1 S&s=S()){___a id26(_2,s);}___6<___ I>auto id23(___1 I&v){___a v>apply(FF(x,___n(x)));}___6<___ I,___...Is>auto id23(___1 I&v,___1 Is&...vs){auto p=id23(vs...);___a v>=FC(x,p>apply(FC(t,std::tuple_cat(___n(x),t),x)),p);}___6<___...Ts>auto id0(___1 Ts&...n){___a id23(range(n)...);}___6<___L n,___ I>auto id38(___1 I&v){___a ___7([](___1 auto&...vs){___a id23(vs...);},id31<n>(v));}___6<___ T>___P auto id5(std::istream&in){id41(std::istream&in;___r T val;bool ___y;___r bool has_read;,___y xor ___x.___y,{if(not(in>>val)){___y=true;}},(has_read)?(val):(has_read=true,in>>val,val))___a ___j(___O{in,T{},false,false},___O{in,T{},true,true});}___6<___ T>___P auto input=id5<T>(std::cin);___6<___ T>___N&id34(___N&out,___1 T&v,___1 std::string&sep= " "){for(auto it=___z(v);it!=___5(v);){ out<<*it;++it;if(it!=___5(v)){out<<sep;}else{___a out;}} ___a out;}___6<___ T,___=___ T::id40>___P ___N&___l<<(___N&out,___1 T&v){out<< "[";for(auto it=___z(v);it!=___5(v);){ out<<*it;++it;if(it!=___5(v)){out<< ", ";}} ___a out<< "]";} 

___1x(___A)___1x(std::map)___1x(std::unordered_map)___1x(std::set)___1x(std::unordered_set)___6<___L n,___ T>___C ___18{___U type=___A<___ ___18<n-1,T>::type>;___D auto make(___1 id7<n,___L>&sz,___1 T&val=T()){___a ___A(id35(sz),___18<n-1,T>::make(tuple_tail(sz),val));}};___6<___ T>___C ___18<1,T>{___U type=___A<T>;___D auto make(___1 ___n<___L>&sz,___1 T&val=T()){___a ___A(id35(sz),val);}};___6<___L n,___ T>___U nested_vector=___ ___18<n,T>::type;___6<___L n,___ T>auto id29(___1 id7<n,___L>&sz,___1 T&val=T()){___a ___18<n,T>::make(sz,val);}___6<___L n,___ T>___P auto id14(___1 T&v){if ___B(n==1){___a ___n(v.size());}else{___a std::tuple_cat(___n(v.size()),id14<n-1>(v[0]));}} ___6<___L n,___ T>___P auto id32(___1 T&v){___a ___7([&](auto...x){___a id0(x...);},id14<n>(v));}___6<___L n,___ T>___P ___3(auto)id42(___1 ___A<T>&v,___1 id7<n,___L>&i){if ___B(n==1){___a v[id35(i)];}else{___a id42<n-1>(v[id35(i)],tuple_tail(i));}} ___6<___L n,___ T>___P ___3(auto)id42(___A<T>&v,___1 id7<n,___L>&i){if ___B(n==1){___a v[id35(i)];}else{___a id42<n-1>(v[id35(i)],tuple_tail(i));}} ___6<___ U,___L i,___L s>___N&id3(___N&out,___1 U&u){if ___B(i==0){out<< "{ ";}out<<___G<i>(u);if ___B(i+1<s){out<< ", ";___a id3<U,i+1,s>(out,u);}else{___a out<< " }";}} ___6<___...Ts>___N&___l<<(___N&out,___1 ___n<Ts...>&u){___a id3<___3(u),0,sizeof...(Ts)>(out,u);}___6<___ T,___ S>___N&___l<<(___N&out,___1 std::pair<T,S>&p){___a out<<___n(p.first,p.second);} 


___U namespace std;___U LL=long long;___6<___ T,___ Merge>class fast_range_tree{___S:___L n,id11;___1 T id;___A<___A<T>>rt;Merge merge;___k:fast_range_tree(___1 T&id_,Merge merge_):id(id_),merge(merge_){} void build(___L n_,___1 T&val){build(val>replicate(n_));}___6<___ I,___=___1C<id19<I>>>void build(___1 I&v){rt.emplace_back(v>___1A);n=rt[0].size();id11=_log2(n-1)+1;for(auto i:range(1,id11+1)){rt.___1_(range(0,rt[i-1].size()/2)>apply(FF(j,merge(rt[i-1][2*j],rt[i-1][2*j+1])))>___1A);if(rt[i-1].size()&1){rt[i].___1_(rt[i-1].back());}}}void id16(___L p,___1 T&v){rt[0][p]=v;for(auto i:range(id11)){p/=2;if(p*2+1<rt[i].size()){rt[i+1][p]=merge(rt[i][p*2],rt[i][p*2+1]);}else{rt[i+1][p]=rt[i][p*2];}}}___6<___ ___w>___P auto point_query(___L p,___w ___q)___1{___a ___q(rt[0][p]);}___P T point_query(___L p)___1{___a rt[0][p];}___6<___ ___w>___P auto ___R(___w ___q)___1{___a ___q(rt.back().back());}___P T ___R()___1{___a rt.back().back();}___6<___ ___w,___ S,___ ___s>auto ___u(___L l,___L r,___1 S&___V,___w ___q,___s ___2)___1{if(l>=r){___a ___V;}S ans=___V;for(int i=0;r-l>=(1<<i);++i){___L j=1<<i;if(l&j){ans=___2(___q(rt[i][l>>i]),ans);l+=j;if(l>=r){___a ans;}} if(r&j){r-=j;ans=___2(ans,___q(rt[i][r>>i]));}} ___a ans;}___P auto ___u(___L l,___L r)___1{___a ___u(l,r,id,_,merge);}___6<___ Pred,___ ___w,___ S,___ ___s>long long ___0(___L l,Pred pred,___1 S&___V,___w ___q,___s ___2)___1{if(pred(___V)){___a l;}if(l==0){if(pred(point_query(0,___q))){___a 1;}else{l=1;}} auto total=___V;for(auto i:range(id11)){if(l>=size()){break;}___L j=1<<i;if(l&j){auto y=___2(total,___q(rt[i][l>>i]));if(pred(y)){for(int k=i-1;k>=0;--k){y=___2(total,___q(rt[k][l>>k]));if(not pred(y)){l+=1<<k;total=y;}} ___a l+1;}else{l+=j;total=y;}}}___a-1;}___6<___ Pred>___P long long ___0(___L l,Pred pred)___1{___a ___0(l,pred,id,_,merge);}___6<___ Pred,___ ___w,___ S,___ ___s>long long ___W(___L r,Pred pred,___1 S&___V,___w ___q,___s ___2)___1{if(pred(___V)){___a r;}auto total=___V;for(auto i:range(id11+1)){___L j=1<<i;if(r&j){auto y=___2(___q(rt[i][(r>>i)-1]),total);if(pred(y)){for(int k=i-1;k>=0;--k){y=___2(___q(rt[k][(r>>k)-1]),total);if(not pred(y)){r-=1<<k;total=y;}} ___a r-1;}else{r-=j;total=y;}}}___a-1;}___6<___ Pred>___P long long ___W(___L r,Pred pred)___1{___a ___W(r,pred,id,_,merge);}___P ___L size()___1{___a n;}};___6<___ T,___ Merge>auto id37(___1 T&id,Merge merge=Merge()){___a fast_range_tree<T,Merge>(id,merge);}___6<___ Idx>___C ___d{Idx l,r;bool contains(___1 ___d&___x)___1{___a l<=___x.l and ___x.r<=r;}bool contains(___1 Idx&p)___1{___a l<=p and p<r;}bool ___m(___1 ___d&___x)___1{___a r<=___x.l or ___x.r<=l;}void left_half(){r=(l+r)/2;}void right_half(){l=(l+r)/2;}Idx size()___1{___a r-l;}};___6<___ Idx,___ T>class ___1T{___S:___L sz;___A<T>tree;___k:class ___f{___S:___1T<Idx,T>*___J;___L j;___d<Idx>i;___k:explicit ___f(___1T<Idx,T>*t):___J(t),j(1),i{0,Idx(t->sz)}{} ___P ___f ___H(){___a*this;}___P void ____(___1 ___f&){} ___P void ___10(___1 ___f&){} ___P void ___8(){i.left_half();j=j*2;}___P void ___M(){i.right_half();j=j*2+1;}___P ___f ___i()___1{___f it(*this);it.___8();___a it;}___P ___f ___h()___1{___f it(*this);it.___M();___a it;}___P bool is_leaf()___1{___a i.size()==1;}___P bool id28()___1{___a i.size()>1;}T&___l*()___1{___a ___J->tree[j];}T*___l->()___1{___a&(___J->tree[j]);}___P auto ___Z()___1{___a i;}___P Idx ___c()___1{___a i.l;}___P Idx ___Y()___1{___a i.r;}};void build(Idx n,___1 T&val){tree.assign(1<<(_log2(n-1)+2),val);sz=n;}___P Idx size()___1{___a sz;}___f ___o(){___a ___f(this);}};___6<___ Idx,___ T>class ___1a{___S:___C vertex{T val;___L l=0,r=0;};T id;Idx sz;___A<vertex>tree;___L ___4(){tree.___1_(vertex{id,0,0});___a tree.size()-1;}___P void ___v(___L j){if(tree[j].l==tree[j].r){tree[j].l=___4();tree[j].r=___4();}} ___k:class ___f{___S:___1a<Idx,T>*___J;___L j;___d<Idx>i;___k:explicit ___f(___1a<Idx,T>*t):___J(t),j(0),i{0,Idx(t->size())}{} ___P void ___v(){___J->___v(j);}___P ___f&___H(){___a*this;}___P void ____(___1 ___f&){} ___P void ___10(___1 ___f&){} ___P void ___8(){___v();i.left_half();j=___J->tree[j].l;}___P void ___M(){___v();i.right_half();j=___J->tree[j].r;}___P ___f ___i()___1{___f it(*this);it.___8();___a it;}___P ___f ___h()___1{___f it(*this);it.___M();___a it;}___P bool is_leaf()___1{___a i.size()==1;}___P bool id28()___1{___a ___J->tree[j].l;}T&___l*()___1{___a ___J->tree[j].val;}T*___l->()___1{___a&(___J->tree[j].val);}___P auto ___Z()___1{___a i;}___P Idx ___c()___1{___a i.l;}___P Idx ___Y()___1{___a i.r;}};void build(Idx n,___1 T&val){id=val;___4();sz=n;}___P Idx size()___1{___a sz;}___f ___o(){___a ___f(this);}};___6<___ Idx,___ T>class ___1R{___S:___C vertex{T val;___L l=0,r=0;};T id;Idx sz;___A<vertex>tree;___L ___4(){tree.___1_(vertex{id,0,0});___a tree.size()-1;}___L ___4(___1 vertex&v){tree.___1_(v);___a tree.size()-1;}___P void ___v(___L j){if(tree[j].l==tree[j].r){tree[j].l=___4();tree[j].r=___4();}} ___k:class ___f{___S:___1R<Idx,T>*___J;___L j;___d<Idx>i;___k:explicit ___f(___1R<Idx,T>*t):___J(t),j(0),i{0,Idx(t->size())}{} ___P void ___v(){___J->___v(j);}___P ___f&___H(){j=___J->___4(___J->tree[j]);___a*this;}___P void ____(___1 ___f&it){___J->tree[j].l=it.j;}___P void ___10(___1 ___f&it){___J->tree[j].r=it.j;}___P void ___8(){___v();i.left_half();j=___J->tree[j].l;}___P void ___M(){___v();i.right_half();j=___J->tree[j].r;}___P ___f ___i()___1{___f it(*this);it.___8();___a it;}___P ___f ___h()___1{___f it(*this);it.___M();___a it;}___P bool is_leaf()___1{___a i.size()==1;}___P bool id28()___1{___a ___J->tree[j].l;}T&___l*()___1{___a ___J->tree[j].val;}T*___l->()___1{___a&(___J->tree[j].val);}___P auto ___Z()___1{___a i;}___P Idx ___c()___1{___a i.l;}___P Idx ___Y()___1{___a i.r;}};void build(Idx n,___1 T&val){id=val;___4();sz=n;}___P Idx size()___1{___a sz;}___f ___o(){___a ___f(this);}};___6<___ Idx,___ ___O,___ ___w,___ ___s>auto id39(___O it,___1 ___d<Idx>&i,___w ___q,___s ___2){if(i.contains(it.___Z())){___a ___q(it.___g());}it.___v();if(i.___m(it.___i().___Z())){___a id39(___O(it.___h()),i,___q,___2);}if(i.___m(it.___h().___Z())){___a id39(___O(it.___i()),i,___q,___2);}___a ___2(id39(___O(it.___i()),i,___q,___2),id39(___O(it.___h()),i,___q,___2));}___6<___ Idx,___ ___O,___ S,___ Pred,___ ___w,___ ___s>___n<S,___1D<Idx>>id10(___O it,Idx l,S total,Pred pred,___w ___q,___s ___2){if(l<=it.___c()){if(pred(total)){___a{total,l};}auto y=___2(total,___q(it.___g()));if(not pred(y)){___a{y,-1};}while(not it.is_leaf()){it.___v();y=___2(total,___q(it.___i().___g()));if(pred(y)){it.___8();}else{it.___M();total=y;}} ___a{total,it.___Y()};}it.___v();if(l>=it.___i().___Y()){___a id10(___O(it.___h()),l,total,pred,___q,___2);}auto[tot_l,ans]=id10(___O(it.___i()),l,total,pred,___q,___2);if(ans==-1){___a id10(___O(it.___h()),l,tot_l,pred,___q,___2);}else{___a{tot_l,ans};}} ___6<___ Idx,___ ___O,___ S,___ Pred,___ ___w,___ ___s>___1D<Idx>___14(___O it,Idx l,___1 S&___V,Pred pred,___w ___q,___s ___2){if(l>=it.___Y()){___a(pred(___V))?(it.___Y()):(-1);}___a ___G<1>(id10(it,l,___V,pred,___q,___2));}___6<___ Idx,___ ___O,___ S,___ Pred,___ ___w,___ ___s>___n<S,___1D<Idx>>id25(___O it,Idx r,S total,Pred pred,___w ___q,___s ___2){if(r>=it.___Y()){if(pred(total)){___a{total,r};}auto y=___2(___q(it.___g()),total);if(not pred(y)){___a{y,-1};}while(not it.is_leaf()){it.___v();y=___2(___q(it.___h().___g()),total);if(pred(y)){it.___M();}else{it.___8();total=y;}} ___a{total,it.___c()};}it.___v();if(r<=it.___h().___c()){___a id25(___O(it.___i()),r,total,pred,___q,___2);}auto[tot_r,ans]=id25(___O(it.___h()),r,total,pred,___q,___2);if(ans==-1){___a id25(___O(it.___i()),r,tot_r,pred,___q,___2);}else{___a{tot_r,ans};}} ___6<___ Idx,___ ___O,___ S,___ Pred,___ ___w,___ ___s>___1D<Idx>id12(___O it,Idx r,___1 S&___V,Pred pred,___w ___q,___s ___2){if(r<=0){___a(pred(___V))?(0):(-1);}___a ___G<1>(id25(it,r,___V,pred,___q,___2));}___6<___ ___Q,___ T,___=void>___C ___1t{___P ___D void f(T&x,___1 T&lc,___1 T&rc,___1 ___Q&){x=___1K(lc,rc);}};___6<___ ___Q,___ T>___C ___1t<___Q,T,___3(___1K(___X<T&>(),___X<T>(),___X<T>(),___X<___Q>()))>{___P ___D void f(T&x,___1 T&lc,___1 T&rc,___1 ___Q&op){___1K(x,lc,rc,op);}};___6<___ Idx,___ T,___ ___I,___ ___O>class base_range_tree{protected:___r ___I bt;___6<___ S>void ___1U(___O it,___1 ___A<S>&v){if(it.___Z().___m(___d<Idx>{0,Idx(v.size())})){___a;}if(it.is_leaf()){it.___g()=v[it.___c()];___a;}___1U(it.___i(),v);___1U(it.___h(),v);it.___g()=Iterator::merge(it.___i().___g(),it.___h().___g());}___k:___D T merge(___1 T&,___1 T&);___P ___O build(Idx n,___1 T&v){bt.build(n,v);___a ___o();}___6<___ I,___=___1C<id19<I>>>___P ___O build(___1 I&v){build(v>___1A);___a ___o();}___6<___ S>___O build(___1 ___A<S>&v){bt.build(v.size(),T{});___1U(___o(),v);___a ___o();}___P ___O ___o()___1{___a bt.___o();}___6<___ ___w>___P auto ___R(___w ___q)___1{___a ___q(___o().___g());}___P auto ___R()___1{___a ___o().___g();}___6<___...Args>___P auto ___u(Args&&...args)___1{___a ___o().___u(___T<Args>(args)...);}___6<___...Args>___P auto ___0(Args&&...args)___1{___a ___o().___0(___T<Args>(args)...);}___6<___...Args>___P auto ___W(Args&&...args)___1{___a ___o().___W(___T<Args>(args)...);}___P ___L size()___1{___a bt.size();}};___6<___ Idx,___ T,___ ___O,___ ___Q>class ___b:___k ___O{___S:___P ___D void full_merge(T&x,___1 T&lc,___1 T&rc,___1 ___Q&op){___1t<___Q,T>::f(x,lc,rc,op);}void ___E(Idx p,___1 ___Q&op){if(this->is_leaf()){op.apply_to(___g(),p);___a;}if(___i().___Z().contains(p)){this->____(___i().___H());___i().___E(p,op);}else{this->___10(___h().___H());___h().___E(p,op);}full_merge(___g(),___i().___g(),___h().___g(),op);}___k:___P ___D auto merge(___1 T&x,___1 T&y){___a ___1K(x,y);}___D ___1 T identity;___b(___1 ___O&___x):___O(___x){} void ___v(){} ___P ___b ___i()___1{___b it(*this);it.___8();___a it;}___P ___b ___h()___1{___b it(*this);it.___M();___a it;}___P T&___g(){___a**this;}___P ___1 T&___g()___1{___a**this;}___6<___ ___w>___P auto ___R(___w ___q)___1{___a ___q(___g());}___P auto ___R()___1{___a ___g();}___6<___ S,___ ___w,___ ___s>___P auto ___u(Idx l,Idx r,___1 S&___V,___w ___q,___s ___2)___1{___d<Idx>i{l,r};if(l<r and not i.___m(this->___Z())){___a id39(*this,i,___q,___2);}else{___a ___V;}} ___P auto ___u(Idx l,Idx r)___1{___a ___u(l,r,id4,_,merge);}___6<___ Pred,___ S,___ ___w,___ ___s>___P auto ___0(Idx l,Pred pred,___1 S&___V,___w ___q,___s ___2)___1{___a ___14(*this,l,___V,pred,___q,___2);}___6<___ Pred>___P auto ___0(Idx l,Pred pred)___1{___a ___14(*this,l,id4,pred,_,merge);}___6<___ Pred,___ S,___ ___w,___ ___s>___P auto ___W(Idx r,Pred pred,___1 S&___V,___w ___q,___s ___2)___1{___a id12(*this,r,___V,pred,___q,___2);}___6<___ Pred>___P auto ___W(Idx r,Pred pred)___1{___a id12(*this,r,id4,pred,_,merge);}___P auto id16(Idx p,___1 ___Q&op){___b it(*this);it.___H();it.___E(p,op);___a it;}};___6<___ Idx,___ T,___ ___O,___ ___Q>___1 T ___b<Idx,T,___O,___Q>::identity=id4;___6<___ Idx,___ T,___6<___,___>___ ___I,___ ___Q>class strict_range_tree:___k base_range_tree<Idx,T,___I<Idx,T>,___b<Idx,T,___ ___I<Idx,T>id36,___Q>>{___k:___U ___f=___ ___b<Idx,T,___ ___I<Idx,T>id36,___Q>id36;___P ___f id16(Idx p,___1 ___Q&op){___a this->___o().id16(p,op);}};___6<___ Idx,___ T,___6<___,___>___ ___I,___ ___Q>auto make_strict_range_tree(){___a strict_range_tree<Idx,T,___I,___Q>();}___6<___ Idx,___ T,___ ___O,___ ___Q>class ___t:___k ___O{___S:___P ___D void full_merge(T&x,___1 T&lc,___1 T&rc,___1 ___Q&op){___1t<___Q,T>::f(x,lc,rc,op);}void ___E(Idx p,___1 ___Q&op){if(this->is_leaf()){op.apply_to(___g(),p,p+1);___a;}if((*this)->no_op()and this->id28()){if(___i().___Z().contains(p)){this->____(___i().___H());___i().___E(p,op);}else{this->___10(___h().___H());___h().___E(p,op);}} else{___v();if(___i().___Z().contains(p)){___i().___E(p,op);}else{___h().___E(p,op);}} full_merge(___g(),___i().___g(),___h().___g(),op);}void ___1O(___d<Idx>i,___1 ___Q&op){if(i.contains(this->___Z())){(*this)->___1g(op.restrict(this->___c(),this->___Y(),i.l,i.r),this->___c(),this->___Y());___a;}if((*this)->no_op()and this->id28()){if(not i.___m(___i().___Z())){this->____(___i().___H());___i().___1O(i,op);}if(not i.___m(___h().___Z())){this->___10(___h().___H());___h().___1O(i,op);}} else{___v();if(not i.___m(___i().___Z())){___i().___1O(i,op);}if(not i.___m(___h().___Z())){___h().___1O(i,op);}} this->full_merge(___g(),___i().___g(),___h().___g(),op);}___k:___P ___D auto merge(___1 T&x,___1 T&y){___a ___1K(x,y);}___D ___1 T identity;___t(___1 ___O&___x):___O(___x){} void ___v(){if((*this)->no_op()){___a;}Idx l=this->___c(),r=this->___Y();Idx m=(l+r)/2;this->____(___i().___H());this->___10(___h().___H());___i()->___1g((*this)->get_operation().restrict(l,m,l,r),l,m);___h()->___1g((*this)->get_operation().restrict(m,r,l,r),m,r);(*this)->delete_operation();}___P ___t ___i()___1{___t it(*this);it.___8();___a it;}___P ___t ___h()___1{___t it(*this);it.___M();___a it;}___P T&___g(){___a(*this)->val;}___P ___1 T&___g()___1{___a(*this)->val;}___6<___ ___w>___P auto ___R(___w ___q)___1{___a ___q(___g());}___P auto ___R()___1{___a ___g();}___6<___ S,___ ___w,___ ___s>___P auto ___u(Idx l,Idx r,___1 S&___V,___w ___q,___s ___2)___1{___d<Idx>i{l,r};if(l<r and not i.___m(this->___Z())){___a id39(*this,i,___q,___2);}else{___a ___V;}} ___P auto ___u(Idx l,Idx r)___1{___a ___u(l,r,id4,_,merge);}___6<___ Pred,___ S,___ ___w,___ ___s>___P auto ___0(Idx l,Pred pred,___1 S&___V,___w ___q,___s ___2)___1{___a ___14(*this,l,___V,pred,___q,___2);}___6<___ Pred>___P auto ___0(Idx l,Pred pred)___1{___a ___14(*this,l,id4,pred,_,merge);}___6<___ Pred,___ S,___ ___w,___ ___s>___P auto ___W(Idx r,Pred pred,___1 S&___V,___w ___q,___s ___2)___1{___a id12(*this,r,___V,pred,___q,___2);}___6<___ Pred>___P auto ___W(Idx r,Pred pred)___1{___a id12(*this,r,id4,pred,_,merge);}___P auto id16(Idx p,___1 ___Q&op){___t it(*this);it.___H();it.___E(p,op);___a it;}___P auto ___21(Idx l,Idx r,___1 ___Q&op){___t it(*this);___d<Idx>i{l,r};if(l<r and not i.___m(this->___Z())){it.___H();it.___1O(i,op);}___a it;}};___6<___ Idx,___ T,___ ___O,___ ___Q>___1 T ___t<Idx,T,___O,___Q>::identity=id4;___6<___ Idx,___ T,___ ___Q>class ___1X{___S:bool id22;___Q op;___k:T val;explicit ___1X(___1 T&val_=T()):id22(false),val(val_){} ___P bool no_op()___1{___a not id22;}void ___1g(___1 ___Q&new_op,Idx l,Idx r){if(no_op()){op=new_op;id22=true;}else{op.append(new_op);}new_op.apply_to(val,l,r);}___P ___1 ___Q&get_operation()___1{___a op;}void delete_operation(){id22=false;}};___6<___ Idx,___ T,___6<___,___>___ ___I,___ ___Q>class lazy_range_tree:___k base_range_tree<Idx,T,___I<Idx,___1X<Idx,T,___Q>>,___t<Idx,T,___ ___I<Idx,___1X<Idx,T,___Q>>id36,___Q>>{___k:___U vertex=___1X<Idx,T,___Q>;___U ___f=___t<Idx,T,___ ___I<Idx,vertex>id36,___Q>;___P ___f build(Idx n,___1 T&v){this->bt.build(n,vertex(v));___a this->___o();}___6<___ I,___=___1C<id19<I>>>___P ___f build(___1 I&v){___a build(v>___1A);}___6<___ S>___f build(___1 ___A<S>&v){this->bt.build(v.size(),vertex(T{}));this->___1U(this->___o(),v);___a this->___o();}___P ___f id16(Idx p,___1 ___Q&op){___a this->___o().id16(p,op);}___P ___f ___21(Idx l,Idx r,___1 ___Q&op){___a this->___o().___21(l,r,op);}};___6<___ Idx,___ T,___6<___,___>___ ___I,___ ___Q,___...Args>auto make_lazy_range_tree(){___a lazy_range_tree<Idx,T,___I,___Q>();}___6<___...Is>class ___1M{___S:___n<Is...>its;___k:___1M(___1 Is&...its_):its(its_...){} ___P auto ___H(){___7([&](auto&&...xs){(xs.___H(),...);},its);___a*this;}___P void ___v(){___7([&](auto&&...xs){(xs.___v(),...);},its);}___P void ____(___1 ___1M&it){___7([&](auto&&...xs){(___G<xs>(its).____(___G<xs>(it)),...);},___1r<Is...>{});}___P void ___10(___1 ___1M&it){___7([&](auto&&...xs){(___G<xs>(its).____(___G<xs>(it)),...);},___1r<Is...>{});}___P void ___8(){___7([&](auto&&...xs){(xs.___8(),...);},its);}___P void ___M(){___7([&](auto&&...xs){(xs.___M(),...);},its);}___P ___1M ___i()___1{auto it=*this;it.___8();___a it;}___P ___1M ___h()___1{auto it=*this;it.___M();___a it;}___P bool is_leaf()___1{___a ___G<0>(its).is_leaf();}___P ___3(auto)___l*()___1{___a ___7([&](auto&&...xs){___a std::forward_as_tuple(xs.___g()...);},its);}___P ___3(auto)___g()___1{___a**this;}___P auto ___Z()___1{___a ___G<0>(its).___Z();}___P auto ___c()___1{___a ___G<0>(its).___c();}___P auto ___Y()___1{___a ___G<0>(its).___Y();}___U T=___n<___p<___3(*___X<Is>())>...>;___U Idx=___p<___3(___G<0>(its).___c())>;___P ___D auto merge(___1 T&x,___1 T&y){___a ___7([&](auto&&...xs){___a ___n(Is::merge(___G<xs>(x),___G<xs>(y))...);},___1r<Is...>{});}___D ___1 T identity;___6<___ ___w>___P auto ___R(___w ___q)___1{___a ___q(___g());}___P auto ___R()___1{___a ___g();}___6<___ S,___ ___w,___ ___s>___P auto ___u(Idx l,Idx r,___1 S&___V,___w ___q,___s ___2)___1{___d<Idx>i{l,r};if(l<r and not i.___m(this->___Z())){___a id39(*this,i,___q,___2);}else{___a ___V;}} ___P auto ___u(Idx l,Idx r)___1{___a ___u(l,r,identity,_,merge);}___6<___ Pred,___ S,___ ___w,___ ___s>___P auto ___0(Idx l,Pred pred,___1 S&___V,___w ___q,___s ___2)___1{___a ___14(*this,l,___V,pred,___q,___2);}___6<___ Pred>___P auto ___0(Idx l,Pred pred)___1{___a ___14(*this,l,identity,pred,_,merge);}___6<___ Pred,___ S,___ ___w,___ ___s>___P auto ___W(Idx r,Pred pred,___1 S&___V,___w ___q,___s ___2)___1{___a id12(*this,r,___V,pred,___q,___2);}___6<___ Pred>___P auto ___W(Idx r,Pred pred)___1{___a id12(*this,r,identity,pred,_,merge);}};___6<___...Is>___1 ___ ___1M<Is...>::T ___1M<Is...>::identity=___n(Is::identity...);___6<___...Is>auto zip_range_trees(___1 Is&...iterators){___a ___1M<Is...>(iterators...);}___C Val{int fours,sevens,lis,lds;};___C ___Q{bool flip;___B ___D Val identity={0,0,0,0};___D Val merge(Val x,Val y){___a{x.fours+y.fours,x.sevens+y.sevens,max(x.fours+y.lis,x.lis+y.sevens),max(x.sevens+y.lds,x.lds+y.fours)};}___Q restrict(int,int,int,int)___1{___a*this;}void apply_to(Val&x,int,int)___1{if(flip){swap(x.fours,x.sevens);swap(x.lis,x.lds);}} void append(___1 ___Q&___x){flip^=___x.flip;}};BEGIN int n,m;cin>>n>>m;auto rt=make_lazy_range_tree<int,Val,___1T,___Q>();rt.build(input<char>>take(n)>apply(FF(c,(c== '4')?(Val{1,0,1,1}):(Val{0,1,1,1}))));while(m--){string s;cin>>s;if(s[0]== 'c'){cout<<rt.___R().lis<< "\n";}else{int l,r;cin>>l>>r;rt.___21(l-1,r,{true});}} END 