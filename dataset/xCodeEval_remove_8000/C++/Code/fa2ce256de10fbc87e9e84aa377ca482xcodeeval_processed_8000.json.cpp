







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































using namespace std;
typedef long long ll;



const int NN = 500010;
ll maxx(ll a, ll b) { if (a > b)return a; else return b; }
ll minx(ll a, ll b) { if (a > b)return b; else return a; }
struct zym {
	int from, to;
} ed[NN<<1];
int tot, head[NN];
void add(int a, int b) {
	ed[++tot].from = head[a];
	head[a] = tot;
	ed[tot].to = b;
	

}
int N, M, S;
int dep[NN], lg[NN], fa[NN][30];
void dfs(int now, int fath) {
	fa[now][0] = fath; dep[now] = dep[fath] + 1;
	for (int i = 1; i <= lg[dep[now]]; i++) {
		fa[now][i] = fa[fa[now][i - 1]][i - 1];
	}
	for (int i = head[now]; i; i = ed[i].from) {
		if (ed[i].to != fath)dfs(ed[i].to, now);
	}
}
int LCA(int x, int y) {
	if (dep[x] < dep[y])swap(x, y);
	while (dep[x] > dep[y])x = fa[x][lg[dep[x] - dep[y]] - 1];
	if (x == y)return x;
	for (int k = lg[dep[x]] - 1; k >= 0; k--) {
		if (fa[x][k] != fa[y][k])x = fa[x][k], y = fa[y][k];
	}
	return fa[x][0];
}
void solve() {
	cin >> N;
	for (int i = 2; i <= N; i++) {
		int a, b;
		cin >> a >> b;
		add(a, b);
		add(b, a);
	}
	for (int i = 1; i <= N; i++) {
		lg[i] = lg[i - 1] + (1 << lg[i - 1] == i);
	}
	dfs(1, 0);
	cin >> M;
	for (int _ = 1; _ <= M; _++) {
		int k;
		cin >> k;
		bool flag = 0;
		int ma = 0;
		vector<int>ss(k + 10);
		
		for (int i = 1; i <= k; i++) {
			cin >> ss[i];
			if (dep[ma] < dep[ss[i]]) {
				ma = ss[i];
			}
		}
		if (k <= 2) {
			cout << "Yes" << endl;
			continue;
		}
		int cma = 0;
		for (int i = 1; i <= k; i++) {
			if (ma!=ss[i]&&LCA(ss[i], ma) != ss[i]) {
				if (dep[cma] < dep[ss[i]]) {
					cma = ss[i];
				}
			}
		}
		

		

		

		

		

		int pp=LCA(ma,cma);
		

		

		

		

		

		for (int i = 1; i <= k; i++) {
			if (ss[i] == ma || ss[i] == cma)continue;
			int u = LCA(ma, ss[i]), v = LCA(cma, ss[i]);
			if (!((u == ss[i] && v == pp) || (u == pp && v == ss[i]))) {
				flag = 1;
				break;
			}
			
		}
		if (flag) {
			cout << "No" << endl;
		}
		else cout << "Yes" << endl;
	}
	return;
}
signed main(void) {
	

	

	

	

	solve();
	return zero;
}
