





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































using namespace std;







typedef unsigned long long ull;
typedef long long ll;
typedef unsigned int ui;

class listNode
{
public:
	int data;
	listNode* next;
	listNode(int val) :data(val), next(NULL) {}
};
class List
{
public:
	listNode* head;
	List() :head(NULL) {}
	void insertAtBegin(int val);
	void insertAtEnd(int val);
	void insertAtPos(int pos, int val);
	void remove(int val);
	listNode* find( int x, int& dist);
	~List();
	void swap(listNode* pos, listNode* end)
	{
		listNode* t = pos->next;
		if (pos->next == end)
			return;
		pos->next = end;
		listNode* hd = t;
		while (t->next != end)
			t = t->next;
		t->next = head;
		head = hd;
	}
};
void List::insertAtEnd(int val) 

{
	if (head == NULL)
	{
		insertAtBegin(val);
		return;
	}
	listNode* newnode = new listNode(val);
	listNode* ptr = this->head;
	while (ptr->next != NULL)
	{
		ptr = ptr->next;
	}
	ptr->next = newnode;
}
void List::insertAtBegin(int val)

{
	listNode* newnode = new listNode(val);
	newnode->next = this->head;
	this->head = newnode;
}
void List::insertAtPos(int pos, int val)
{
	listNode* newnode = new listNode(val);
	if (pos == 1)
	{
		

		newnode->next = this->head;
		this->head = newnode;
		return;
	}
	pos--;
	listNode* ptr = this->head;
	while (ptr != NULL && --pos)
	{
		ptr = ptr->next;
	}
	if (ptr == NULL)
		return;

	newnode->next = ptr->next;
	ptr->next = newnode;
}
void List::remove(int id0)

{
	if (this->head == NULL)
		return; 

	if (this->head->data == id0)
	{
		

		listNode* temp = this->head;
		this->head = this->head->next;
		delete(temp);
		return;
	}
	listNode* ptr = this->head;
	while (ptr->next != NULL && ptr->next->data != id0)
		ptr = ptr->next;
	if (ptr->next == NULL)
		return;

	listNode* temp = ptr->next;
	ptr->next = ptr->next->next;
	delete(temp);
}
listNode* List::find(int x, int& dist)

{
	dist = 1;
	listNode* ptr = this->head;
	while (ptr != NULL)
	{
		if (ptr->data == x)
			return ptr;
		ptr = ptr->next;
		dist++;
	}
	return NULL;
}
List::~List()
{
	listNode* ptr = this->head, * next = NULL;
	while (ptr != NULL)
	{
		next = ptr->next;
		delete(ptr);
		ptr = next;
	}
}



void solve()
{
	size_t n; cin >> n;
	List lt;
	for (size_t i = 0; i < n; i++)
	{
		int x; cin >> x;
		lt.insertAtEnd(x);
	}
	vector<int> ans;
	listNode* prv = NULL;
	for (int i = n; i > 0 ; i--)
	{
		int dist;
		auto ps = lt.find(i, dist);
		lt.swap(ps, prv);
		prv = ps;
		ans.push_back(dist % i);
	}
	for (auto i = ans.rbegin(); i != ans.rend(); ++i)
		cout << *i << " ";
	cout << endl;
}

int main(int argc, char const** argv)
{

	freopen("in.txt", "r", stdin);

	ios_base::sync_with_stdio(0);
	cout.tie(0);
	cin.tie(0);
	constexpr int  mult = 1;
	int _ = 1;
	if (mult)
		std::cin >> _;
	while (_--)
	{
		solve();
	}

	return 0;
}