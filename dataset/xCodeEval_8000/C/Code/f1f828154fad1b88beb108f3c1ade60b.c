#include <stdio.h>
#include <stdlib.h>

static struct cmc_alloc_node
{
    void *(*malloc)(size_t);
    void *(*calloc)(size_t, size_t);
    void *(*realloc)(void *, size_t);
    void (*free)(void *);
} cmc_alloc_node_default = { malloc, calloc, realloc, free };
struct cmc_callbacks
{
    void (*create)(void);
    void (*read)(void);
    void (*update)(void);
    void (*delete)(void);
    void (*resize)(void);
};
enum cmc_flags
{
    CMC_FLAG_OK = 0,
    CMC_FLAG_ALLOC = 1,
    CMC_FLAG_EMPTY = 2,
    CMC_FLAG_NOT_FOUND = 3,
    CMC_FLAG_INVALID = 4,
    CMC_FLAG_RANGE = 5,
    CMC_FLAG_DUPLICATE = 6,
    CMC_FLAG_ERROR = 7,
    CMC_FLAG_THREAD = 8,
    CMC_FLAG_MUTEX = 9
};
__attribute__((__unused__)) static const char *cmc_flags_to_str[10] = { "OK", "ALLOC", "EMPTY", "NOT_FOUND", "INVALID",
                                                       "RANGE", "DUPLICATE", "ERROR", "THREAD", "MUTEX" };
static inline int cmc_long_cmp(long x1, long x2)
{
    return (x1 > x2) - (x1 < x2);
}
struct fragment {
 long len;
 long b;
};
static inline int fragment_compare(struct fragment f1, struct fragment f2) {
 if (f1.len < f2.len) {
  return -1;
 } else if (f1.len > f2.len) {
  return 1;
 }
 return f1.b - f2.b;
}
struct lset { struct lset_node * root; size_t count; int flag; struct lset_fval * f_val; struct cmc_alloc_node *alloc; struct cmc_callbacks *callbacks; }; struct lset_node { long value; unsigned char height; struct lset_node * right; struct lset_node * left; struct lset_node * parent; }; struct lset_fval { int (*cmp)(long, long); long (*cpy)(long); _Bool (*str)(FILE *, long); void (*free)(long); size_t (*hash)(long); int (*pri)(long, long); }; struct lset *ls_new(struct lset_fval * f_val); struct lset *ls_new_custom(struct lset_fval * f_val, struct cmc_alloc_node * alloc, struct cmc_callbacks * callbacks); void ls_clear(struct lset * _set_); void ls_free(struct lset * _set_); _Bool ls_insert(struct lset * _set_, long value); _Bool ls_remove(struct lset * _set_, long value); _Bool ls_max(struct lset * _set_, long * value); _Bool ls_min(struct lset * _set_, long * value); _Bool ls_contains(struct lset * _set_, long value); _Bool ls_empty(struct lset * _set_); size_t ls_count(struct lset * _set_); int ls_flag(struct lset * _set_); struct lset *ls_copy_of(struct lset * _set_); _Bool ls_equals(struct lset * _set1_, struct lset * _set2_); struct lset_iter { struct lset *target; struct lset_node * cursor; struct lset_node * first; struct lset_node * last; size_t index; _Bool start; _Bool end; }; struct lset_iter ls_iter_start(struct lset * target); struct lset_iter ls_iter_end(struct lset * target); _Bool ls_iter_at_start(struct lset_iter * iter); _Bool ls_iter_at_end(struct lset_iter * iter); _Bool ls_iter_to_start(struct lset_iter * iter); _Bool ls_iter_to_end(struct lset_iter * iter); _Bool ls_iter_next(struct lset_iter * iter); _Bool ls_iter_prev(struct lset_iter * iter); _Bool ls_iter_advance(struct lset_iter * iter, size_t steps); _Bool ls_iter_rewind(struct lset_iter * iter, size_t steps); _Bool ls_iter_go_to(struct lset_iter * iter, size_t index); long ls_iter_value(struct lset_iter * iter); size_t ls_iter_index(struct lset_iter * iter); struct lset *ls_union(struct lset * _set1_, struct lset * _set2_); struct lset *ls_intersection(struct lset * _set1_, struct lset * _set2_); struct lset *ls_difference(struct lset * _set1_, struct lset * _set2_); struct lset *ls_symmetric_difference(struct lset * _set1_, struct lset * _set2_); _Bool ls_is_subset(struct lset * _set1_, struct lset * _set2_); _Bool ls_is_superset(struct lset * _set1_, struct lset * _set2_); _Bool ls_is_proper_subset(struct lset * _set1_, struct lset * _set2_); _Bool ls_is_proper_superset(struct lset * _set1_, struct lset * _set2_); _Bool ls_is_disjointset(struct lset * _set1_, struct lset * _set2_); _Bool ls_to_string(struct lset * _set_, FILE * fptr); _Bool ls_print(struct lset * _set_, FILE * fptr, const char *start, const char *separator, const char *end); static struct lset_node * ls_impl_new_node(struct lset * _set_, long value); static struct lset_node * ls_impl_get_node(struct lset * _set_, long value); static unsigned char ls_impl_h(struct lset_node * node); static unsigned char ls_impl_hupdate(struct lset_node * node); static void ls_impl_rotate_right(struct lset_node * *Z); static void ls_impl_rotate_left(struct lset_node * *Z); static void ls_impl_rebalance(struct lset * _set_, struct lset_node * node); struct lset *ls_new(struct lset_fval * f_val) { return ls_new_custom(f_val, ((void *)0), ((void *)0)); } struct lset *ls_new_custom(struct lset_fval * f_val, struct cmc_alloc_node * alloc, struct cmc_callbacks * callbacks) { ; if (!f_val) return ((void *)0); if (!alloc) alloc = &cmc_alloc_node_default; struct lset *_set_ = alloc->malloc(sizeof(struct lset)); if (!_set_) return ((void *)0); _set_->count = 0; _set_->root = ((void *)0); _set_->flag = CMC_FLAG_OK; _set_->f_val = f_val; _set_->alloc = alloc; (_set_)->callbacks = callbacks; return _set_; } void ls_clear(struct lset * _set_) { struct lset_node *scan = _set_->root; struct lset_node *up = ((void *)0); while (scan != ((void *)0)) { if (scan->left != ((void *)0)) { struct lset_node *left = scan->left; scan->left = up; up = scan; scan = left; } else if (scan->right != ((void *)0)) { struct lset_node *right = scan->right; scan->left = up; scan->right = ((void *)0); up = scan; scan = right; } else { if (up == ((void *)0)) { if (_set_->f_val->free) _set_->f_val->free(scan->value); _set_->alloc->free(scan); scan = ((void *)0); } while (up != ((void *)0)) { if (_set_->f_val->free) _set_->f_val->free(scan->value); _set_->alloc->free(scan); if (up->right != ((void *)0)) { scan = up->right; up->right = ((void *)0); break; } else { scan = up; up = up->left; } } } } _set_->count = 0; _set_->root = ((void *)0); _set_->flag = CMC_FLAG_OK; } void ls_free(struct lset * _set_) { ls_clear(_set_); _set_->alloc->free(_set_); } _Bool ls_insert(struct lset * _set_, long value) { if (ls_empty(_set_)) { _set_->root = ls_impl_new_node(_set_, value); if (!_set_->root) { _set_->flag = CMC_FLAG_ALLOC; return 0; } } else { struct lset_node *scan = _set_->root; struct lset_node *parent = scan; while (scan != ((void *)0)) { parent = scan; if (_set_->f_val->cmp(scan->value, value) > 0) scan = scan->left; else if (_set_->f_val->cmp(scan->value, value) < 0) scan = scan->right; else { _set_->flag = CMC_FLAG_DUPLICATE; return 0; } } struct lset_node * node; if (_set_->f_val->cmp(parent->value, value) > 0) { parent->left = ls_impl_new_node(_set_, value); if (!parent->left) { _set_->flag = CMC_FLAG_ALLOC; return 0; } parent->left->parent = parent; node = parent->left; } else { parent->right = ls_impl_new_node(_set_, value); if (!parent->right) { _set_->flag = CMC_FLAG_ALLOC; return 0; } parent->right->parent = parent; node = parent->right; } ls_impl_rebalance(_set_, node); } _set_->count++; _set_->flag = CMC_FLAG_OK; if ((_set_)->callbacks && (_set_)->callbacks->create) (_set_)->callbacks->create();; return 1; } _Bool ls_remove(struct lset * _set_, long value) { if (ls_empty(_set_)) { _set_->flag = CMC_FLAG_EMPTY; return 0; } struct lset_node *node = ls_impl_get_node(_set_, value); if (!node) { _set_->flag = CMC_FLAG_NOT_FOUND; return 0; } struct lset_node *temp = ((void *)0), *unbalanced = ((void *)0); _Bool is_root = node->parent == ((void *)0); if (node->left == ((void *)0) && node->right == ((void *)0)) { if (is_root) _set_->root = ((void *)0); else { unbalanced = node->parent; if (node->parent->right == node) node->parent->right = ((void *)0); else node->parent->left = ((void *)0); } _set_->alloc->free(node); } else if (node->left == ((void *)0)) { if (is_root) { _set_->root = node->right; _set_->root->parent = ((void *)0); } else { unbalanced = node->parent; node->right->parent = node->parent; if (node->parent->right == node) node->parent->right = node->right; else node->parent->left = node->right; } _set_->alloc->free(node); } else if (node->right == ((void *)0)) { if (is_root) { _set_->root = node->left; _set_->root->parent = ((void *)0); } else { unbalanced = node->parent; node->left->parent = node->parent; if (node->parent->right == node) node->parent->right = node->left; else node->parent->left = node->left; } _set_->alloc->free(node); } else { temp = node->right; while (temp->left != ((void *)0)) temp = temp->left; long temp_value = temp->value; unbalanced = temp->parent; if (temp->left == ((void *)0) && temp->right == ((void *)0)) { if (temp->parent->right == temp) temp->parent->right = ((void *)0); else temp->parent->left = ((void *)0); } else if (temp->left == ((void *)0)) { temp->right->parent = temp->parent; if (temp->parent->right == temp) temp->parent->right = temp->right; else temp->parent->left = temp->right; } else if (temp->right == ((void *)0)) { temp->left->parent = temp->parent; if (temp->parent->right == temp) temp->parent->right = temp->left; else temp->parent->left = temp->left; } _set_->alloc->free(temp); node->value = temp_value; } if (unbalanced != ((void *)0)) ls_impl_rebalance(_set_, unbalanced); if (_set_->count == 0) _set_->root = ((void *)0); _set_->count--; _set_->flag = CMC_FLAG_OK; if ((_set_)->callbacks && (_set_)->callbacks->delete) (_set_)->callbacks->delete();; return 1; } _Bool ls_max(struct lset * _set_, long * value) { if (ls_empty(_set_)) { _set_->flag = CMC_FLAG_EMPTY; return 0; } struct lset_node *scan = _set_->root; while (scan->right != ((void *)0)) scan = scan->right; if (value) *value = scan->value; _set_->flag = CMC_FLAG_OK; if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return 1; } _Bool ls_min(struct lset * _set_, long * value) { if (ls_empty(_set_)) { _set_->flag = CMC_FLAG_EMPTY; return 0; } struct lset_node *scan = _set_->root; while (scan->left != ((void *)0)) scan = scan->left; if (value) *value = scan->value; _set_->flag = CMC_FLAG_OK; if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return 1; } _Bool ls_contains(struct lset * _set_, long value) { _Bool result = ls_impl_get_node(_set_, value) != ((void *)0); if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return result; } _Bool ls_empty(struct lset * _set_) { return _set_->count == 0; } size_t ls_count(struct lset * _set_) { return _set_->count; } int ls_flag(struct lset * _set_) { return _set_->flag; } struct lset *ls_copy_of(struct lset * _set_) { struct lset *result = ls_new_custom(_set_->f_val, _set_->alloc, ((void *)0)); if (!result) { _set_->flag = CMC_FLAG_ERROR; return ((void *)0); } (result)->callbacks = _set_->callbacks; if (!ls_empty(_set_)) { struct lset_iter iter = ls_iter_start(_set_); for (; !ls_iter_at_end(&iter); ls_iter_next(&iter)) { if (_set_->f_val->cpy) ls_insert (result, _set_->f_val->cpy(ls_iter_value(&iter))); else ls_insert(result, ls_iter_value(&iter)); } } _set_->flag = CMC_FLAG_OK; return result; } _Bool ls_equals(struct lset * _set1_, struct lset * _set2_) { _set1_->flag = CMC_FLAG_OK; _set2_->flag = CMC_FLAG_OK; if (_set1_->count != _set2_->count) return 0; struct lset_iter iter = ls_iter_start(_set1_); for (; !ls_iter_at_end(&iter); ls_iter_next(&iter)) { if (ls_impl_get_node(_set2_, ls_iter_value(&iter)) == ((void *)0)) return 0; } return 1; } static struct lset_node * ls_impl_new_node(struct lset * _set_, long value) { struct lset_node *node = _set_->alloc->malloc(sizeof(struct lset_node)); if (!node) return ((void *)0); node->value = value; node->right = ((void *)0); node->left = ((void *)0); node->parent = ((void *)0); node->height = 0; return node; } static struct lset_node * ls_impl_get_node(struct lset * _set_, long value) { struct lset_node *scan = _set_->root; while (scan != ((void *)0)) { if (_set_->f_val->cmp(scan->value, value) > 0) scan = scan->left; else if (_set_->f_val->cmp(scan->value, value) < 0) scan = scan->right; else return scan; } return ((void *)0); } static unsigned char ls_impl_h(struct lset_node * node) { if (node == ((void *)0)) return 0; return node->height; } static unsigned char ls_impl_hupdate(struct lset_node * node) { if (node == ((void *)0)) return 0; unsigned char h_l = ls_impl_h(node->left); unsigned char h_r = ls_impl_h(node->right); return 1 + (h_l > h_r ? h_l : h_r); } static void ls_impl_rotate_right(struct lset_node * *Z) { struct lset_node *root = *Z; struct lset_node *new_root = root->left; if (root->parent != ((void *)0)) { if (root->parent->left == root) root->parent->left = new_root; else root->parent->right = new_root; } new_root->parent = root->parent; root->parent = new_root; root->left = new_root->right; if (root->left) root->left->parent = root; new_root->right = root; root->height = ls_impl_hupdate(root); new_root->height = ls_impl_hupdate(new_root); *Z = new_root; } static void ls_impl_rotate_left(struct lset_node * *Z) { struct lset_node *root = *Z; struct lset_node *new_root = root->right; if (root->parent != ((void *)0)) { if (root->parent->right == root) root->parent->right = new_root; else root->parent->left = new_root; } new_root->parent = root->parent; root->parent = new_root; root->right = new_root->left; if (root->right) root->right->parent = root; new_root->left = root; root->height = ls_impl_hupdate(root); new_root->height = ls_impl_hupdate(new_root); *Z = new_root; } static void ls_impl_rebalance(struct lset * _set_, struct lset_node * node) { struct lset_node *scan = node, *child = ((void *)0); int balance; _Bool is_root = 0; while (scan != ((void *)0)) { if (scan->parent == ((void *)0)) is_root = 1; scan->height = ls_impl_hupdate(scan); balance = ls_impl_h(scan->right) - ls_impl_h(scan->left); if (balance >= 2) { child = scan->right; if (ls_impl_h(child->right) < ls_impl_h(child->left)) ls_impl_rotate_right(&(scan->right)); ls_impl_rotate_left(&scan); } else if (balance <= -2) { child = scan->left; if (ls_impl_h(child->left) < ls_impl_h(child->right)) ls_impl_rotate_left(&(scan->left)); ls_impl_rotate_right(&scan); } if (is_root) { _set_->root = scan; is_root = 0; } scan = scan->parent; } } struct lset_iter ls_iter_start(struct lset * target) { struct lset_iter iter; iter.target = target; iter.cursor = target->root; iter.first = ((void *)0); iter.last = ((void *)0); iter.index = 0; iter.start = 1; iter.end = ls_empty(target); if (!ls_empty(target)) { while (iter.cursor->left != ((void *)0)) iter.cursor = iter.cursor->left; iter.first = iter.cursor; iter.last = target->root; while (iter.last->right != ((void *)0)) iter.last = iter.last->right; } return iter; } struct lset_iter ls_iter_end(struct lset * target) { struct lset_iter iter; iter.target = target; iter.cursor = target->root; iter.first = ((void *)0); iter.last = ((void *)0); iter.index = 0; iter.start = ls_empty(target); iter.end = 1; if (!ls_empty(target)) { while (iter.cursor->right != ((void *)0)) iter.cursor = iter.cursor->right; iter.last = iter.cursor; iter.first = target->root; while (iter.first->left != ((void *)0)) iter.first = iter.first->left; iter.index = target->count - 1; } return iter; } _Bool ls_iter_at_start(struct lset_iter * iter) { return ls_empty(iter->target) || iter->start; } _Bool ls_iter_at_end(struct lset_iter * iter) { return ls_empty(iter->target) || iter->end; } _Bool ls_iter_to_start(struct lset_iter * iter) { if (!ls_empty(iter->target)) { iter->index = 0; iter->start = 1; iter->end = ls_empty(iter->target); iter->cursor = iter->first; return 1; } return 0; } _Bool ls_iter_to_end(struct lset_iter * iter) { if (!ls_empty(iter->target)) { iter->index = iter->target->count - 1; iter->start = ls_empty(iter->target); iter->end = 1; iter->cursor = iter->last; return 1; } return 0; } _Bool ls_iter_next(struct lset_iter * iter) { if (iter->end) return 0; if (iter->cursor == iter->last) { iter->end = 1; return 0; } iter->start = ls_empty(iter->target); if (iter->cursor->right != ((void *)0)) { iter->cursor = iter->cursor->right; while (iter->cursor->left != ((void *)0)) iter->cursor = iter->cursor->left; iter->index++; return 1; } while (1) { if (iter->cursor->parent->left == iter->cursor) { iter->cursor = iter->cursor->parent; iter->index++; return 1; } iter->cursor = iter->cursor->parent; } } _Bool ls_iter_prev(struct lset_iter * iter) { if (iter->start) return 0; if (iter->cursor == iter->first) { iter->start = 1; return 0; } iter->end = ls_empty(iter->target); if (iter->cursor->left != ((void *)0)) { iter->cursor = iter->cursor->left; while (iter->cursor->right != ((void *)0)) iter->cursor = iter->cursor->right; iter->index--; return 1; } while (1) { if (iter->cursor->parent->right == iter->cursor) { iter->cursor = iter->cursor->parent; iter->index--; return 1; } iter->cursor = iter->cursor->parent; } } _Bool ls_iter_advance(struct lset_iter * iter, size_t steps) { if (iter->end) return 0; if (iter->cursor == iter->last) { iter->end = 1; return 0; } if (steps == 0 || iter->index + steps >= iter->target->count) return 0; for (size_t i = 0; i < steps; i++) ls_iter_next(iter); return 1; } _Bool ls_iter_rewind(struct lset_iter * iter, size_t steps) { if (iter->start) return 0; if (iter->cursor == iter->first) { iter->start = 1; return 0; } if (steps == 0 || iter->index < steps) return 0; for (size_t i = 0; i < steps; i++) ls_iter_prev(iter); return 1; } _Bool ls_iter_go_to(struct lset_iter * iter, size_t index) { if (index >= iter->target->count) return 0; if (iter->index > index) return ls_iter_rewind(iter, iter->index - index); else if (iter->index < index) return ls_iter_advance(iter, index - iter->index); return 1; } long ls_iter_value(struct lset_iter * iter) { if (ls_empty(iter->target)) return (long){ 0 }; return iter->cursor->value; } size_t ls_iter_index(struct lset_iter * iter) { return iter->index; } struct lset *ls_union(struct lset * _set1_, struct lset * _set2_) { struct lset *_set_r_ = ls_new_custom(_set1_->f_val, _set1_->alloc, ((void *)0)); if (!_set_r_) return ((void *)0); struct lset_iter iter1 = ls_iter_start(_set1_); struct lset_iter iter2 = ls_iter_start(_set2_); for (; !ls_iter_at_end(&iter1); ls_iter_next(&iter1)) { ls_insert(_set_r_, ls_iter_value(&iter1)); } for (; !ls_iter_at_end(&iter2); ls_iter_next(&iter2)) { ls_insert(_set_r_, ls_iter_value(&iter2)); } (_set_r_)->callbacks = _set1_->callbacks; return _set_r_; } struct lset *ls_intersection(struct lset * _set1_, struct lset * _set2_) { struct lset *_set_r_ = ls_new_custom(_set1_->f_val, _set1_->alloc, ((void *)0)); if (!_set_r_) return ((void *)0); struct lset *_set_A_ = _set1_->count < _set2_->count ? _set1_ : _set2_; struct lset *_set_B_ = _set_A_ == _set1_ ? _set2_ : _set1_; struct lset_iter iter = ls_iter_start(_set_A_); for (; !ls_iter_at_end(&iter); ls_iter_next(&iter)) { long value = ls_iter_value(&iter); if (ls_impl_get_node(_set_B_, value) != ((void *)0)) ls_insert(_set_r_, value); } (_set_r_)->callbacks = _set1_->callbacks; return _set_r_; } struct lset *ls_difference(struct lset * _set1_, struct lset * _set2_) { struct lset *_set_r_ = ls_new_custom(_set1_->f_val, _set1_->alloc, ((void *)0)); if (!_set_r_) return ((void *)0); struct lset_iter iter = ls_iter_start(_set1_); for (; !ls_iter_at_end(&iter); ls_iter_next(&iter)) { long value = ls_iter_value(&iter); if (ls_impl_get_node(_set2_, value) == ((void *)0)) ls_insert(_set_r_, value); } (_set_r_)->callbacks = _set1_->callbacks; return _set_r_; } struct lset *ls_symmetric_difference(struct lset * _set1_, struct lset * _set2_) { struct lset *_set_r_ = ls_new_custom(_set1_->f_val, _set1_->alloc, ((void *)0)); if (!_set_r_) return ((void *)0); struct lset_iter iter1 = ls_iter_start(_set1_); struct lset_iter iter2 = ls_iter_start(_set2_); for (; !ls_iter_at_end(&iter1); ls_iter_next(&iter1)) { long value = ls_iter_value(&iter1); if (ls_impl_get_node(_set2_, value) == ((void *)0)) ls_insert(_set_r_, value); } for (; !ls_iter_at_end(&iter2); ls_iter_next(&iter2)) { long value = ls_iter_value(&iter2); if (ls_impl_get_node(_set1_, value) == ((void *)0)) ls_insert(_set_r_, value); } (_set_r_)->callbacks = _set1_->callbacks; return _set_r_; } _Bool ls_is_subset(struct lset * _set1_, struct lset * _set2_) { if (_set1_->count > _set2_->count) return 0; if (ls_empty(_set1_)) return 1; struct lset_iter iter = ls_iter_start(_set1_); for (; !ls_iter_at_end(&iter); ls_iter_next(&iter)) { long value = ls_iter_value(&iter); if (ls_impl_get_node(_set2_, value) == ((void *)0)) return 0; } return 1; } _Bool ls_is_superset(struct lset * _set1_, struct lset * _set2_) { return ls_is_subset(_set2_, _set1_); } _Bool ls_is_proper_subset(struct lset * _set1_, struct lset * _set2_) { if (_set1_->count >= _set2_->count) return 0; if (ls_empty(_set1_)) { if (!ls_empty(_set2_)) return 1; else return 0; } struct lset_iter iter = ls_iter_start(_set1_); for (; !ls_iter_at_end(&iter); ls_iter_next(&iter)) { long value = ls_iter_value(&iter); if (ls_impl_get_node(_set2_, value) == ((void *)0)) return 0; } return 1; } _Bool ls_is_proper_superset(struct lset * _set1_, struct lset * _set2_) { return ls_is_proper_subset(_set2_, _set1_); } _Bool ls_is_disjointset(struct lset * _set1_, struct lset * _set2_) { if (ls_empty(_set1_)) return 1; struct lset_iter iter = ls_iter_start(_set1_); for (; !ls_iter_at_end(&iter); ls_iter_next(&iter)) { long value = ls_iter_value(&iter); if (ls_impl_get_node(_set2_, value) != ((void *)0)) return 0; } return 1; } _Bool ls_to_string(struct lset * _set_, FILE * fptr) { struct lset *s_ = _set_; return 0 <= fprintf(fptr, "struct %s<%s> " "at %p { " "root:%p, " "count:%" "l" "u" ", " "flag:%d, " "f_val:%p, " "alloc:%p, " "callbacks:%p }", "lset", "long", s_, s_->root, s_->count, s_->flag, s_->f_val, s_->alloc, (s_)->callbacks); } _Bool ls_print(struct lset * _set_, FILE * fptr, const char *start, const char *separator, const char *end) { fprintf(fptr, "%s", start); struct lset_node *root = _set_->root; _Bool left_done = 0; size_t i = 0; while (root) { if (!left_done) { while (root->left) root = root->left; } if (!_set_->f_val->str(fptr, root->value)) return 0; if (++i < _set_->count) fprintf(fptr, "%s", separator); left_done = 1; if (root->right) { left_done = 0; root = root->right; } else if (root->parent) { while (root->parent && root == root->parent->right) root = root->parent; if (!root->parent) break; root = root->parent; } else break; } fprintf(fptr, "%s", end); return 1; }
struct fset { struct fset_node * root; size_t count; int flag; struct fset_fval * f_val; struct cmc_alloc_node *alloc; struct cmc_callbacks *callbacks; }; struct fset_node { struct fragment value; unsigned char height; struct fset_node * right; struct fset_node * left; struct fset_node * parent; }; struct fset_fval { int (*cmp)(struct fragment, struct fragment); struct fragment (*cpy)(struct fragment); _Bool (*str)(FILE *, struct fragment); void (*free)(struct fragment); size_t (*hash)(struct fragment); int (*pri)(struct fragment, struct fragment); }; struct fset *fs_new(struct fset_fval * f_val); struct fset *fs_new_custom(struct fset_fval * f_val, struct cmc_alloc_node * alloc, struct cmc_callbacks * callbacks); void fs_clear(struct fset * _set_); void fs_free(struct fset * _set_); _Bool fs_insert(struct fset * _set_, struct fragment value); _Bool fs_remove(struct fset * _set_, struct fragment value); _Bool fs_max(struct fset * _set_, struct fragment * value); _Bool fs_min(struct fset * _set_, struct fragment * value); _Bool fs_contains(struct fset * _set_, struct fragment value); _Bool fs_empty(struct fset * _set_); size_t fs_count(struct fset * _set_); int fs_flag(struct fset * _set_); struct fset *fs_copy_of(struct fset * _set_); _Bool fs_equals(struct fset * _set1_, struct fset * _set2_); struct fset_iter { struct fset *target; struct fset_node * cursor; struct fset_node * first; struct fset_node * last; size_t index; _Bool start; _Bool end; }; struct fset_iter fs_iter_start(struct fset * target); struct fset_iter fs_iter_end(struct fset * target); _Bool fs_iter_at_start(struct fset_iter * iter); _Bool fs_iter_at_end(struct fset_iter * iter); _Bool fs_iter_to_start(struct fset_iter * iter); _Bool fs_iter_to_end(struct fset_iter * iter); _Bool fs_iter_next(struct fset_iter * iter); _Bool fs_iter_prev(struct fset_iter * iter); _Bool fs_iter_advance(struct fset_iter * iter, size_t steps); _Bool fs_iter_rewind(struct fset_iter * iter, size_t steps); _Bool fs_iter_go_to(struct fset_iter * iter, size_t index); struct fragment fs_iter_value(struct fset_iter * iter); size_t fs_iter_index(struct fset_iter * iter); struct fset *fs_union(struct fset * _set1_, struct fset * _set2_); struct fset *fs_intersection(struct fset * _set1_, struct fset * _set2_); struct fset *fs_difference(struct fset * _set1_, struct fset * _set2_); struct fset *fs_symmetric_difference(struct fset * _set1_, struct fset * _set2_); _Bool fs_is_subset(struct fset * _set1_, struct fset * _set2_); _Bool fs_is_superset(struct fset * _set1_, struct fset * _set2_); _Bool fs_is_proper_subset(struct fset * _set1_, struct fset * _set2_); _Bool fs_is_proper_superset(struct fset * _set1_, struct fset * _set2_); _Bool fs_is_disjointset(struct fset * _set1_, struct fset * _set2_); _Bool fs_to_string(struct fset * _set_, FILE * fptr); _Bool fs_print(struct fset * _set_, FILE * fptr, const char *start, const char *separator, const char *end); static struct fset_node * fs_impl_new_node(struct fset * _set_, struct fragment value); static struct fset_node * fs_impl_get_node(struct fset * _set_, struct fragment value); static unsigned char fs_impl_h(struct fset_node * node); static unsigned char fs_impl_hupdate(struct fset_node * node); static void fs_impl_rotate_right(struct fset_node * *Z); static void fs_impl_rotate_left(struct fset_node * *Z); static void fs_impl_rebalance(struct fset * _set_, struct fset_node * node); struct fset *fs_new(struct fset_fval * f_val) { return fs_new_custom(f_val, ((void *)0), ((void *)0)); } struct fset *fs_new_custom(struct fset_fval * f_val, struct cmc_alloc_node * alloc, struct cmc_callbacks * callbacks) { ; if (!f_val) return ((void *)0); if (!alloc) alloc = &cmc_alloc_node_default; struct fset *_set_ = alloc->malloc(sizeof(struct fset)); if (!_set_) return ((void *)0); _set_->count = 0; _set_->root = ((void *)0); _set_->flag = CMC_FLAG_OK; _set_->f_val = f_val; _set_->alloc = alloc; (_set_)->callbacks = callbacks; return _set_; } void fs_clear(struct fset * _set_) { struct fset_node *scan = _set_->root; struct fset_node *up = ((void *)0); while (scan != ((void *)0)) { if (scan->left != ((void *)0)) { struct fset_node *left = scan->left; scan->left = up; up = scan; scan = left; } else if (scan->right != ((void *)0)) { struct fset_node *right = scan->right; scan->left = up; scan->right = ((void *)0); up = scan; scan = right; } else { if (up == ((void *)0)) { if (_set_->f_val->free) _set_->f_val->free(scan->value); _set_->alloc->free(scan); scan = ((void *)0); } while (up != ((void *)0)) { if (_set_->f_val->free) _set_->f_val->free(scan->value); _set_->alloc->free(scan); if (up->right != ((void *)0)) { scan = up->right; up->right = ((void *)0); break; } else { scan = up; up = up->left; } } } } _set_->count = 0; _set_->root = ((void *)0); _set_->flag = CMC_FLAG_OK; } void fs_free(struct fset * _set_) { fs_clear(_set_); _set_->alloc->free(_set_); } _Bool fs_insert(struct fset * _set_, struct fragment value) { if (fs_empty(_set_)) { _set_->root = fs_impl_new_node(_set_, value); if (!_set_->root) { _set_->flag = CMC_FLAG_ALLOC; return 0; } } else { struct fset_node *scan = _set_->root; struct fset_node *parent = scan; while (scan != ((void *)0)) { parent = scan; if (_set_->f_val->cmp(scan->value, value) > 0) scan = scan->left; else if (_set_->f_val->cmp(scan->value, value) < 0) scan = scan->right; else { _set_->flag = CMC_FLAG_DUPLICATE; return 0; } } struct fset_node * node; if (_set_->f_val->cmp(parent->value, value) > 0) { parent->left = fs_impl_new_node(_set_, value); if (!parent->left) { _set_->flag = CMC_FLAG_ALLOC; return 0; } parent->left->parent = parent; node = parent->left; } else { parent->right = fs_impl_new_node(_set_, value); if (!parent->right) { _set_->flag = CMC_FLAG_ALLOC; return 0; } parent->right->parent = parent; node = parent->right; } fs_impl_rebalance(_set_, node); } _set_->count++; _set_->flag = CMC_FLAG_OK; if ((_set_)->callbacks && (_set_)->callbacks->create) (_set_)->callbacks->create();; return 1; } _Bool fs_remove(struct fset * _set_, struct fragment value) { if (fs_empty(_set_)) { _set_->flag = CMC_FLAG_EMPTY; return 0; } struct fset_node *node = fs_impl_get_node(_set_, value); if (!node) { _set_->flag = CMC_FLAG_NOT_FOUND; return 0; } struct fset_node *temp = ((void *)0), *unbalanced = ((void *)0); _Bool is_root = node->parent == ((void *)0); if (node->left == ((void *)0) && node->right == ((void *)0)) { if (is_root) _set_->root = ((void *)0); else { unbalanced = node->parent; if (node->parent->right == node) node->parent->right = ((void *)0); else node->parent->left = ((void *)0); } _set_->alloc->free(node); } else if (node->left == ((void *)0)) { if (is_root) { _set_->root = node->right; _set_->root->parent = ((void *)0); } else { unbalanced = node->parent; node->right->parent = node->parent; if (node->parent->right == node) node->parent->right = node->right; else node->parent->left = node->right; } _set_->alloc->free(node); } else if (node->right == ((void *)0)) { if (is_root) { _set_->root = node->left; _set_->root->parent = ((void *)0); } else { unbalanced = node->parent; node->left->parent = node->parent; if (node->parent->right == node) node->parent->right = node->left; else node->parent->left = node->left; } _set_->alloc->free(node); } else { temp = node->right; while (temp->left != ((void *)0)) temp = temp->left; struct fragment temp_value = temp->value; unbalanced = temp->parent; if (temp->left == ((void *)0) && temp->right == ((void *)0)) { if (temp->parent->right == temp) temp->parent->right = ((void *)0); else temp->parent->left = ((void *)0); } else if (temp->left == ((void *)0)) { temp->right->parent = temp->parent; if (temp->parent->right == temp) temp->parent->right = temp->right; else temp->parent->left = temp->right; } else if (temp->right == ((void *)0)) { temp->left->parent = temp->parent; if (temp->parent->right == temp) temp->parent->right = temp->left; else temp->parent->left = temp->left; } _set_->alloc->free(temp); node->value = temp_value; } if (unbalanced != ((void *)0)) fs_impl_rebalance(_set_, unbalanced); if (_set_->count == 0) _set_->root = ((void *)0); _set_->count--; _set_->flag = CMC_FLAG_OK; if ((_set_)->callbacks && (_set_)->callbacks->delete) (_set_)->callbacks->delete();; return 1; } _Bool fs_max(struct fset * _set_, struct fragment * value) { if (fs_empty(_set_)) { _set_->flag = CMC_FLAG_EMPTY; return 0; } struct fset_node *scan = _set_->root; while (scan->right != ((void *)0)) scan = scan->right; if (value) *value = scan->value; _set_->flag = CMC_FLAG_OK; if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return 1; } _Bool fs_min(struct fset * _set_, struct fragment * value) { if (fs_empty(_set_)) { _set_->flag = CMC_FLAG_EMPTY; return 0; } struct fset_node *scan = _set_->root; while (scan->left != ((void *)0)) scan = scan->left; if (value) *value = scan->value; _set_->flag = CMC_FLAG_OK; if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return 1; } _Bool fs_contains(struct fset * _set_, struct fragment value) { _Bool result = fs_impl_get_node(_set_, value) != ((void *)0); if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return result; } _Bool fs_empty(struct fset * _set_) { return _set_->count == 0; } size_t fs_count(struct fset * _set_) { return _set_->count; } int fs_flag(struct fset * _set_) { return _set_->flag; } struct fset *fs_copy_of(struct fset * _set_) { struct fset *result = fs_new_custom(_set_->f_val, _set_->alloc, ((void *)0)); if (!result) { _set_->flag = CMC_FLAG_ERROR; return ((void *)0); } (result)->callbacks = _set_->callbacks; if (!fs_empty(_set_)) { struct fset_iter iter = fs_iter_start(_set_); for (; !fs_iter_at_end(&iter); fs_iter_next(&iter)) { if (_set_->f_val->cpy) fs_insert (result, _set_->f_val->cpy(fs_iter_value(&iter))); else fs_insert(result, fs_iter_value(&iter)); } } _set_->flag = CMC_FLAG_OK; return result; } _Bool fs_equals(struct fset * _set1_, struct fset * _set2_) { _set1_->flag = CMC_FLAG_OK; _set2_->flag = CMC_FLAG_OK; if (_set1_->count != _set2_->count) return 0; struct fset_iter iter = fs_iter_start(_set1_); for (; !fs_iter_at_end(&iter); fs_iter_next(&iter)) { if (fs_impl_get_node(_set2_, fs_iter_value(&iter)) == ((void *)0)) return 0; } return 1; } static struct fset_node * fs_impl_new_node(struct fset * _set_, struct fragment value) { struct fset_node *node = _set_->alloc->malloc(sizeof(struct fset_node)); if (!node) return ((void *)0); node->value = value; node->right = ((void *)0); node->left = ((void *)0); node->parent = ((void *)0); node->height = 0; return node; } static struct fset_node * fs_impl_get_node(struct fset * _set_, struct fragment value) { struct fset_node *scan = _set_->root; while (scan != ((void *)0)) { if (_set_->f_val->cmp(scan->value, value) > 0) scan = scan->left; else if (_set_->f_val->cmp(scan->value, value) < 0) scan = scan->right; else return scan; } return ((void *)0); } static unsigned char fs_impl_h(struct fset_node * node) { if (node == ((void *)0)) return 0; return node->height; } static unsigned char fs_impl_hupdate(struct fset_node * node) { if (node == ((void *)0)) return 0; unsigned char h_l = fs_impl_h(node->left); unsigned char h_r = fs_impl_h(node->right); return 1 + (h_l > h_r ? h_l : h_r); } static void fs_impl_rotate_right(struct fset_node * *Z) { struct fset_node *root = *Z; struct fset_node *new_root = root->left; if (root->parent != ((void *)0)) { if (root->parent->left == root) root->parent->left = new_root; else root->parent->right = new_root; } new_root->parent = root->parent; root->parent = new_root; root->left = new_root->right; if (root->left) root->left->parent = root; new_root->right = root; root->height = fs_impl_hupdate(root); new_root->height = fs_impl_hupdate(new_root); *Z = new_root; } static void fs_impl_rotate_left(struct fset_node * *Z) { struct fset_node *root = *Z; struct fset_node *new_root = root->right; if (root->parent != ((void *)0)) { if (root->parent->right == root) root->parent->right = new_root; else root->parent->left = new_root; } new_root->parent = root->parent; root->parent = new_root; root->right = new_root->left; if (root->right) root->right->parent = root; new_root->left = root; root->height = fs_impl_hupdate(root); new_root->height = fs_impl_hupdate(new_root); *Z = new_root; } static void fs_impl_rebalance(struct fset * _set_, struct fset_node * node) { struct fset_node *scan = node, *child = ((void *)0); int balance; _Bool is_root = 0; while (scan != ((void *)0)) { if (scan->parent == ((void *)0)) is_root = 1; scan->height = fs_impl_hupdate(scan); balance = fs_impl_h(scan->right) - fs_impl_h(scan->left); if (balance >= 2) { child = scan->right; if (fs_impl_h(child->right) < fs_impl_h(child->left)) fs_impl_rotate_right(&(scan->right)); fs_impl_rotate_left(&scan); } else if (balance <= -2) { child = scan->left; if (fs_impl_h(child->left) < fs_impl_h(child->right)) fs_impl_rotate_left(&(scan->left)); fs_impl_rotate_right(&scan); } if (is_root) { _set_->root = scan; is_root = 0; } scan = scan->parent; } } struct fset_iter fs_iter_start(struct fset * target) { struct fset_iter iter; iter.target = target; iter.cursor = target->root; iter.first = ((void *)0); iter.last = ((void *)0); iter.index = 0; iter.start = 1; iter.end = fs_empty(target); if (!fs_empty(target)) { while (iter.cursor->left != ((void *)0)) iter.cursor = iter.cursor->left; iter.first = iter.cursor; iter.last = target->root; while (iter.last->right != ((void *)0)) iter.last = iter.last->right; } return iter; } struct fset_iter fs_iter_end(struct fset * target) { struct fset_iter iter; iter.target = target; iter.cursor = target->root; iter.first = ((void *)0); iter.last = ((void *)0); iter.index = 0; iter.start = fs_empty(target); iter.end = 1; if (!fs_empty(target)) { while (iter.cursor->right != ((void *)0)) iter.cursor = iter.cursor->right; iter.last = iter.cursor; iter.first = target->root; while (iter.first->left != ((void *)0)) iter.first = iter.first->left; iter.index = target->count - 1; } return iter; } _Bool fs_iter_at_start(struct fset_iter * iter) { return fs_empty(iter->target) || iter->start; } _Bool fs_iter_at_end(struct fset_iter * iter) { return fs_empty(iter->target) || iter->end; } _Bool fs_iter_to_start(struct fset_iter * iter) { if (!fs_empty(iter->target)) { iter->index = 0; iter->start = 1; iter->end = fs_empty(iter->target); iter->cursor = iter->first; return 1; } return 0; } _Bool fs_iter_to_end(struct fset_iter * iter) { if (!fs_empty(iter->target)) { iter->index = iter->target->count - 1; iter->start = fs_empty(iter->target); iter->end = 1; iter->cursor = iter->last; return 1; } return 0; } _Bool fs_iter_next(struct fset_iter * iter) { if (iter->end) return 0; if (iter->cursor == iter->last) { iter->end = 1; return 0; } iter->start = fs_empty(iter->target); if (iter->cursor->right != ((void *)0)) { iter->cursor = iter->cursor->right; while (iter->cursor->left != ((void *)0)) iter->cursor = iter->cursor->left; iter->index++; return 1; } while (1) { if (iter->cursor->parent->left == iter->cursor) { iter->cursor = iter->cursor->parent; iter->index++; return 1; } iter->cursor = iter->cursor->parent; } } _Bool fs_iter_prev(struct fset_iter * iter) { if (iter->start) return 0; if (iter->cursor == iter->first) { iter->start = 1; return 0; } iter->end = fs_empty(iter->target); if (iter->cursor->left != ((void *)0)) { iter->cursor = iter->cursor->left; while (iter->cursor->right != ((void *)0)) iter->cursor = iter->cursor->right; iter->index--; return 1; } while (1) { if (iter->cursor->parent->right == iter->cursor) { iter->cursor = iter->cursor->parent; iter->index--; return 1; } iter->cursor = iter->cursor->parent; } } _Bool fs_iter_advance(struct fset_iter * iter, size_t steps) { if (iter->end) return 0; if (iter->cursor == iter->last) { iter->end = 1; return 0; } if (steps == 0 || iter->index + steps >= iter->target->count) return 0; for (size_t i = 0; i < steps; i++) fs_iter_next(iter); return 1; } _Bool fs_iter_rewind(struct fset_iter * iter, size_t steps) { if (iter->start) return 0; if (iter->cursor == iter->first) { iter->start = 1; return 0; } if (steps == 0 || iter->index < steps) return 0; for (size_t i = 0; i < steps; i++) fs_iter_prev(iter); return 1; } _Bool fs_iter_go_to(struct fset_iter * iter, size_t index) { if (index >= iter->target->count) return 0; if (iter->index > index) return fs_iter_rewind(iter, iter->index - index); else if (iter->index < index) return fs_iter_advance(iter, index - iter->index); return 1; } struct fragment fs_iter_value(struct fset_iter * iter) { if (fs_empty(iter->target)) return (struct fragment){ 0 }; return iter->cursor->value; } size_t fs_iter_index(struct fset_iter * iter) { return iter->index; } struct fset *fs_union(struct fset * _set1_, struct fset * _set2_) { struct fset *_set_r_ = fs_new_custom(_set1_->f_val, _set1_->alloc, ((void *)0)); if (!_set_r_) return ((void *)0); struct fset_iter iter1 = fs_iter_start(_set1_); struct fset_iter iter2 = fs_iter_start(_set2_); for (; !fs_iter_at_end(&iter1); fs_iter_next(&iter1)) { fs_insert(_set_r_, fs_iter_value(&iter1)); } for (; !fs_iter_at_end(&iter2); fs_iter_next(&iter2)) { fs_insert(_set_r_, fs_iter_value(&iter2)); } (_set_r_)->callbacks = _set1_->callbacks; return _set_r_; } struct fset *fs_intersection(struct fset * _set1_, struct fset * _set2_) { struct fset *_set_r_ = fs_new_custom(_set1_->f_val, _set1_->alloc, ((void *)0)); if (!_set_r_) return ((void *)0); struct fset *_set_A_ = _set1_->count < _set2_->count ? _set1_ : _set2_; struct fset *_set_B_ = _set_A_ == _set1_ ? _set2_ : _set1_; struct fset_iter iter = fs_iter_start(_set_A_); for (; !fs_iter_at_end(&iter); fs_iter_next(&iter)) { struct fragment value = fs_iter_value(&iter); if (fs_impl_get_node(_set_B_, value) != ((void *)0)) fs_insert(_set_r_, value); } (_set_r_)->callbacks = _set1_->callbacks; return _set_r_; } struct fset *fs_difference(struct fset * _set1_, struct fset * _set2_) { struct fset *_set_r_ = fs_new_custom(_set1_->f_val, _set1_->alloc, ((void *)0)); if (!_set_r_) return ((void *)0); struct fset_iter iter = fs_iter_start(_set1_); for (; !fs_iter_at_end(&iter); fs_iter_next(&iter)) { struct fragment value = fs_iter_value(&iter); if (fs_impl_get_node(_set2_, value) == ((void *)0)) fs_insert(_set_r_, value); } (_set_r_)->callbacks = _set1_->callbacks; return _set_r_; } struct fset *fs_symmetric_difference(struct fset * _set1_, struct fset * _set2_) { struct fset *_set_r_ = fs_new_custom(_set1_->f_val, _set1_->alloc, ((void *)0)); if (!_set_r_) return ((void *)0); struct fset_iter iter1 = fs_iter_start(_set1_); struct fset_iter iter2 = fs_iter_start(_set2_); for (; !fs_iter_at_end(&iter1); fs_iter_next(&iter1)) { struct fragment value = fs_iter_value(&iter1); if (fs_impl_get_node(_set2_, value) == ((void *)0)) fs_insert(_set_r_, value); } for (; !fs_iter_at_end(&iter2); fs_iter_next(&iter2)) { struct fragment value = fs_iter_value(&iter2); if (fs_impl_get_node(_set1_, value) == ((void *)0)) fs_insert(_set_r_, value); } (_set_r_)->callbacks = _set1_->callbacks; return _set_r_; } _Bool fs_is_subset(struct fset * _set1_, struct fset * _set2_) { if (_set1_->count > _set2_->count) return 0; if (fs_empty(_set1_)) return 1; struct fset_iter iter = fs_iter_start(_set1_); for (; !fs_iter_at_end(&iter); fs_iter_next(&iter)) { struct fragment value = fs_iter_value(&iter); if (fs_impl_get_node(_set2_, value) == ((void *)0)) return 0; } return 1; } _Bool fs_is_superset(struct fset * _set1_, struct fset * _set2_) { return fs_is_subset(_set2_, _set1_); } _Bool fs_is_proper_subset(struct fset * _set1_, struct fset * _set2_) { if (_set1_->count >= _set2_->count) return 0; if (fs_empty(_set1_)) { if (!fs_empty(_set2_)) return 1; else return 0; } struct fset_iter iter = fs_iter_start(_set1_); for (; !fs_iter_at_end(&iter); fs_iter_next(&iter)) { struct fragment value = fs_iter_value(&iter); if (fs_impl_get_node(_set2_, value) == ((void *)0)) return 0; } return 1; } _Bool fs_is_proper_superset(struct fset * _set1_, struct fset * _set2_) { return fs_is_proper_subset(_set2_, _set1_); } _Bool fs_is_disjointset(struct fset * _set1_, struct fset * _set2_) { if (fs_empty(_set1_)) return 1; struct fset_iter iter = fs_iter_start(_set1_); for (; !fs_iter_at_end(&iter); fs_iter_next(&iter)) { struct fragment value = fs_iter_value(&iter); if (fs_impl_get_node(_set2_, value) != ((void *)0)) return 0; } return 1; } _Bool fs_to_string(struct fset * _set_, FILE * fptr) { struct fset *s_ = _set_; return 0 <= fprintf(fptr, "struct %s<%s> " "at %p { " "root:%p, " "count:%" "l" "u" ", " "flag:%d, " "f_val:%p, " "alloc:%p, " "callbacks:%p }", "fset", "struct fragment", s_, s_->root, s_->count, s_->flag, s_->f_val, s_->alloc, (s_)->callbacks); } _Bool fs_print(struct fset * _set_, FILE * fptr, const char *start, const char *separator, const char *end) { fprintf(fptr, "%s", start); struct fset_node *root = _set_->root; _Bool left_done = 0; size_t i = 0; while (root) { if (!left_done) { while (root->left) root = root->left; } if (!_set_->f_val->str(fptr, root->value)) return 0; if (++i < _set_->count) fprintf(fptr, "%s", separator); left_done = 1; if (root->right) { left_done = 0; root = root->right; } else if (root->parent) { while (root->parent && root == root->parent->right) root = root->parent; if (!root->parent) break; root = root->parent; } else break; } fprintf(fptr, "%s", end); return 1; } ;

long moves(struct lset *piles, struct fset *fragments) {
	if (ls_count(piles) <= 2) {
		return 0;
	}
	long max_pile, min_pile;
	ls_max(piles, &max_pile);
	ls_min(piles, &min_pile);
	struct fragment max_frag;
	fs_max(fragments, &max_frag);
	return max_pile - min_pile - max_frag.len;
}

static struct lset_node* lset_impl_get_node(struct lset_node * nd, long value) {
    while (nd != NULL) { 
        if (nd->value > value) {
            nd = nd->left;
        } else if (nd->value < value) {
            nd = nd->right;
        }	else {
            break;
        }
    }
    return nd;
}

static struct lset_node* lset_impl_get_node_gte(struct lset_node *nd, long value) {
	if (nd == NULL || nd->value == value) {
		return nd;
	}
	if (nd->value < value) {
		return lset_impl_get_node_gte(nd->right, value);
	}
	struct lset_node *gte = lset_impl_get_node_gte(nd->left, value);
	return (gte && gte->value >= value)? gte: nd;
}

static struct lset_node* lset_impl_tree_min(struct lset_node* nd) {
	if (nd->left != NULL) {
		return lset_impl_tree_min(nd->left);
	}
	return nd;
}

static struct lset_node* lset_impl_tree_max(struct lset_node* nd) {
	if (nd->right != NULL) {
		return lset_impl_tree_max(nd->right);
	}
	return nd;
}
static struct lset_node* lset_impl_tree_predecessor(struct lset_node* nd) {
	if (nd->left != NULL) {
		return lset_impl_tree_max(nd->left);
	}
	struct lset_node* par = nd->parent;
	while (par != NULL && nd == par->left) {
		nd = par;
		par = par->parent;
	}
	return par;
}

static struct lset_node* lset_impl_tree_successor(struct lset_node* nd) {
	if (nd->right != NULL) {
		return lset_impl_tree_min(nd->right);
	}
	struct lset_node* par = nd->parent;
	while (par != NULL && nd == par->right) {
		nd = par;
		par = par->parent;
	}
	return par;
}

int main() {
	struct lset *piles = ls_new(&(struct lset_fval){
		.cmp = cmc_long_cmp
	});
	int n, q;
	scanf("%d%d", &n, &q);
	for (int i = 0; i < n; ++i) {
		long pile;
		scanf("%ld", &pile);
		ls_insert(piles, pile);
	}
	struct fset *fragments = fs_new(&(struct fset_fval){
		.cmp = fragment_compare
	});
	{
		long b, e;
		struct lset_iter it = ls_iter_start(piles);
		for (;!ls_iter_at_end(&it); ls_iter_next(&it)) {
			if (ls_iter_at_start(&it)) {
				b = ls_iter_value(&it);
			} else {
				e = ls_iter_value(&it);
				fs_insert(fragments, (struct fragment){e - b, b});
				b = e;
			}
		}
	}
	printf("%ld\n", moves(piles, fragments));
	for (int i = 0; i < q; ++i) {
		long t, x;
		scanf("%ld%ld", &t, &x);
        long max_pile, min_pile;
        ls_max(piles, &max_pile);
        ls_min(piles, &min_pile);	
		if (t == 0) {
			if (ls_count(piles) > 1) {
				struct lset_node *nd = lset_impl_get_node(piles->root, x);			
				if (x == min_pile) {
					struct lset_node *nxt = lset_impl_tree_successor(nd);
					fs_remove(fragments, (struct fragment){nxt->value - nd->value, nd->value});
				} else if (x == max_pile) {
					struct lset_node *prv = lset_impl_tree_predecessor(nd);
					fs_remove(fragments, (struct fragment){nd->value - prv->value, prv->value});
				} else {
					struct lset_node *nxt = lset_impl_tree_successor(nd);
					struct lset_node *prv = lset_impl_tree_predecessor(nd);
					fs_remove(fragments, (struct fragment){nxt->value - nd->value, nd->value});
					fs_remove(fragments, (struct fragment){nd->value - prv->value, prv->value});
					fs_insert(fragments, (struct fragment){nxt->value - prv->value, prv->value});
				}
			}
			ls_remove(piles, x);
		} else {
			if (ls_count(piles) > 0) {
				if (x < min_pile) {
					fs_insert(fragments, (struct fragment){min_pile - x, x});
				} else if (max_pile < x) {
					fs_insert(fragments, (struct fragment){x - max_pile, max_pile});
				} else {
					struct lset_node *nxt = lset_impl_get_node_gte(piles->root, x);
					struct lset_node *prv = lset_impl_tree_predecessor(nxt);
					fs_insert(fragments, (struct fragment){nxt->value - x, x});
					fs_insert(fragments, (struct fragment){x - prv->value, prv->value});
					fs_remove(fragments, (struct fragment){nxt->value - prv->value, prv->value});
				}
			}
			ls_insert(piles, x);
		}
		printf("%ld\n", moves(piles, fragments));
	}
	ls_free(piles);
	fs_free(fragments);
	return 0;
}