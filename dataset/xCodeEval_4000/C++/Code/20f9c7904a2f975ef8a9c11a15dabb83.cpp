#define _CRT_SECURE_NO_WARNINGS
#include <cassert>
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <ciso646>
#include <climits>
#include <clocale>
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <ccomplex>
#include <cfenv>
#include <cinttypes>
#include <cstdalign>
#include <cstdbool>
#include <cstdint>
#include <ctgmath>
#include <cwchar>
#include <cwctype>
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <typeinfo>
#include <type_traits>
#include <utility>
#include <valarray>
#include <vector>
#include <array>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <typeindex>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































using namespace std;

#define LMAX 9223372036854775807ll
#define IMAX 2147483647
#define LMIN -9223372036854775808ll
#define IMIN -2147483648
#define all(a) a.begin(), a.end()

typedef unsigned long long ull;
typedef long long ll;
typedef unsigned int ui;

class listNode
{
public:
	int data;
	listNode* next;
	listNode(int val) :data(val), next(NULL) {}
};
class List
{
public:
	listNode* head;
	List() :head(NULL) {}
	void insertAtBegin(int val);
	void insertAtEnd(int val);
	void insertAtPos(int pos, int val);
	void remove(int val);
	listNode* find( int x, int& dist);
	~List();
	void swap(listNode* pos, listNode* end)
	{
		listNode* t = pos->next;
		if (pos->next == end)
			return;
		pos->next = end;
		listNode* hd = t;
		while (t->next != end)
			t = t->next;
		t->next = head;
		head = hd;
	}
};
void List::insertAtEnd(int val) 

{
	if (head == NULL)
	{
		insertAtBegin(val);
		return;
	}
	listNode* newnode = new listNode(val);
	listNode* ptr = this->head;
	while (ptr->next != NULL)
	{
		ptr = ptr->next;
	}
	ptr->next = newnode;
}
void List::insertAtBegin(int val)

{
	listNode* newnode = new listNode(val);
	newnode->next = this->head;
	this->head = newnode;
}
void List::insertAtPos(int pos, int val)
{
	listNode* newnode = new listNode(val);
	if (pos == 1)
	{
		

		newnode->next = this->head;
		this->head = newnode;
		return;
	}
	pos--;
	listNode* ptr = this->head;
	while (ptr != NULL && --pos)
	{
		ptr = ptr->next;
	}
	if (ptr == NULL)
		return;

	newnode->next = ptr->next;
	ptr->next = newnode;
}
void List::remove(int toBeRemoved)

{
	if (this->head == NULL)
		return; 

	if (this->head->data == toBeRemoved)
	{
		

		listNode* temp = this->head;
		this->head = this->head->next;
		delete(temp);
		return;
	}
	listNode* ptr = this->head;
	while (ptr->next != NULL && ptr->next->data != toBeRemoved)
		ptr = ptr->next;
	if (ptr->next == NULL)
		return;

	listNode* temp = ptr->next;
	ptr->next = ptr->next->next;
	delete(temp);
}
listNode* List::find(int x, int& dist)

{
	dist = 1;
	listNode* ptr = this->head;
	while (ptr != NULL)
	{
		if (ptr->data == x)
			return ptr;
		ptr = ptr->next;
		dist++;
	}
	return NULL;
}
List::~List()
{
	listNode* ptr = this->head, * next = NULL;
	while (ptr != NULL)
	{
		next = ptr->next;
		delete(ptr);
		ptr = next;
	}
}



void solve()
{
	size_t n; cin >> n;
	List lt;
	for (size_t i = 0; i < n; i++)
	{
		int x; cin >> x;
		lt.insertAtEnd(x);
	}
	vector<int> ans;
	listNode* prv = NULL;
	for (int i = n; i > 0 ; i--)
	{
		int dist;
		auto ps = lt.find(i, dist);
		lt.swap(ps, prv);
		prv = ps;
		ans.push_back(dist % i);
	}
	for (auto i = ans.rbegin(); i != ans.rend(); ++i)
		cout << *i << " ";
	cout << endl;
}

int main(int argc, char const** argv)
{
#ifdef ABESSE
	freopen("in.txt", "r", stdin);
#endif
	ios_base::sync_with_stdio(0);
	cout.tie(0);
	cin.tie(0);
	constexpr int  mult = 1;
	int _ = 1;
	if (mult)
		std::cin >> _;
	while (_--)
	{
		solve();
	}

	return 0;
}