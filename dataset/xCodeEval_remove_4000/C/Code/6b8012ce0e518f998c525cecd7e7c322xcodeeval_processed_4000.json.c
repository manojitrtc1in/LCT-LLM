


static struct cmc_alloc_node
{
    void *(*malloc)(size_t);
    void *(*calloc)(size_t, size_t);
    void *(*realloc)(void *, size_t);
    void (*free)(void *);
} id10 = { malloc, calloc, realloc, free };
struct cmc_callbacks
{
    void (*create)(void);
    void (*read)(void);
    void (*update)(void);
    void (*delete)(void);
    void (*resize)(void);
};
enum cmc_flags
{
    id78 = 0,
    id41 = 1,
    id63 = 2,
    id2 = 3,
    CMC_FLAG_INVALID = 4,
    CMC_FLAG_RANGE = 5,
    id19 = 6,
    id26 = 7,
    CMC_FLAG_THREAD = 8,
    CMC_FLAG_MUTEX = 9
};
__attribute__((__unused__)) static const char *id24[10] = { "OK", "ALLOC", "EMPTY", "NOT_FOUND", "INVALID",
                                                       "RANGE", "DUPLICATE", "ERROR", "THREAD", "MUTEX" };
static inline int id29(long x1, long x2)
{
    return (x1 > x2) - (x1 < x2);
}
struct fragment {
 long len;
 long b;
};
static inline int fragment_compare(struct fragment f1, struct fragment f2) {
 if (f1.len < f2.len) {
  return -1;
 } else if (f1.len > f2.len) {
  return 1;
 }
 return f1.b - f2.b;
}
struct lset { struct lset_node * root; size_t count; int flag; struct lset_fval * f_val; struct cmc_alloc_node *alloc; struct cmc_callbacks *callbacks; }; struct lset_node { long value; unsigned char height; struct lset_node * right; struct lset_node * left; struct lset_node * parent; }; struct lset_fval { int (*cmp)(long, long); long (*cpy)(long); _Bool (*str)(FILE *, long); void (*free)(long); size_t (*hash)(long); int (*pri)(long, long); }; struct lset *ls_new(struct lset_fval * f_val); struct lset *id58(struct lset_fval * f_val, struct cmc_alloc_node * alloc, struct cmc_callbacks * callbacks); void ls_clear(struct lset * _set_); void ls_free(struct lset * _set_); _Bool ls_insert(struct lset * _set_, long value); _Bool ls_remove(struct lset * _set_, long value); _Bool ls_max(struct lset * _set_, long * value); _Bool ls_min(struct lset * _set_, long * value); _Bool ls_contains(struct lset * _set_, long value); _Bool ls_empty(struct lset * _set_); size_t ls_count(struct lset * _set_); int ls_flag(struct lset * _set_); struct lset *id23(struct lset * _set_); _Bool ls_equals(struct lset * id69, struct lset * id15); struct lset_iter { struct lset *target; struct lset_node * cursor; struct lset_node * first; struct lset_node * last; size_t index; _Bool start; _Bool end; }; struct lset_iter id59(struct lset * target); struct lset_iter id80(struct lset * target); _Bool id35(struct lset_iter * iter); _Bool id11(struct lset_iter * iter); _Bool id54(struct lset_iter * iter); _Bool id37(struct lset_iter * iter); _Bool id25(struct lset_iter * iter); _Bool id13(struct lset_iter * iter); _Bool id74(struct lset_iter * iter, size_t steps); _Bool id71(struct lset_iter * iter, size_t steps); _Bool id72(struct lset_iter * iter, size_t index); long id66(struct lset_iter * iter); size_t id50(struct lset_iter * iter); struct lset *ls_union(struct lset * id69, struct lset * id15); struct lset *id3(struct lset * id69, struct lset * id15); struct lset *ls_difference(struct lset * id69, struct lset * id15); struct lset *id48(struct lset * id69, struct lset * id15); _Bool id64(struct lset * id69, struct lset * id15); _Bool id32(struct lset * id69, struct lset * id15); _Bool id67(struct lset * id69, struct lset * id15); _Bool id4(struct lset * id69, struct lset * id15); _Bool id62(struct lset * id69, struct lset * id15); _Bool id6(struct lset * _set_, FILE * fptr); _Bool ls_print(struct lset * _set_, FILE * fptr, const char *start, const char *separator, const char *end); static struct lset_node * id42(struct lset * _set_, long value); static struct lset_node * id81(struct lset * _set_, long value); static unsigned char id65(struct lset_node * node); static unsigned char id52(struct lset_node * node); static void id20(struct lset_node * *Z); static void id21(struct lset_node * *Z); static void id18(struct lset * _set_, struct lset_node * node); struct lset *ls_new(struct lset_fval * f_val) { return id58(f_val, ((void *)0), ((void *)0)); } struct lset *id58(struct lset_fval * f_val, struct cmc_alloc_node * alloc, struct cmc_callbacks * callbacks) { ; if (!f_val) return ((void *)0); if (!alloc) alloc = &id10; struct lset *_set_ = alloc->malloc(sizeof(struct lset)); if (!_set_) return ((void *)0); _set_->count = 0; _set_->root = ((void *)0); _set_->flag = id78; _set_->f_val = f_val; _set_->alloc = alloc; (_set_)->callbacks = callbacks; return _set_; } void ls_clear(struct lset * _set_) { struct lset_node *scan = _set_->root; struct lset_node *up = ((void *)0); while (scan != ((void *)0)) { if (scan->left != ((void *)0)) { struct lset_node *left = scan->left; scan->left = up; up = scan; scan = left; } else if (scan->right != ((void *)0)) { struct lset_node *right = scan->right; scan->left = up; scan->right = ((void *)0); up = scan; scan = right; } else { if (up == ((void *)0)) { if (_set_->f_val->free) _set_->f_val->free(scan->value); _set_->alloc->free(scan); scan = ((void *)0); } while (up != ((void *)0)) { if (_set_->f_val->free) _set_->f_val->free(scan->value); _set_->alloc->free(scan); if (up->right != ((void *)0)) { scan = up->right; up->right = ((void *)0); break; } else { scan = up; up = up->left; } } } } _set_->count = 0; _set_->root = ((void *)0); _set_->flag = id78; } void ls_free(struct lset * _set_) { ls_clear(_set_); _set_->alloc->free(_set_); } _Bool ls_insert(struct lset * _set_, long value) { if (ls_empty(_set_)) { _set_->root = id42(_set_, value); if (!_set_->root) { _set_->flag = id41; return 0; } } else { struct lset_node *scan = _set_->root; struct lset_node *parent = scan; while (scan != ((void *)0)) { parent = scan; if (_set_->f_val->cmp(scan->value, value) > 0) scan = scan->left; else if (_set_->f_val->cmp(scan->value, value) < 0) scan = scan->right; else { _set_->flag = id19; return 0; } } struct lset_node * node; if (_set_->f_val->cmp(parent->value, value) > 0) { parent->left = id42(_set_, value); if (!parent->left) { _set_->flag = id41; return 0; } parent->left->parent = parent; node = parent->left; } else { parent->right = id42(_set_, value); if (!parent->right) { _set_->flag = id41; return 0; } parent->right->parent = parent; node = parent->right; } id18(_set_, node); } _set_->count++; _set_->flag = id78; if ((_set_)->callbacks && (_set_)->callbacks->create) (_set_)->callbacks->create();; return 1; } _Bool ls_remove(struct lset * _set_, long value) { if (ls_empty(_set_)) { _set_->flag = id63; return 0; } struct lset_node *node = id81(_set_, value); if (!node) { _set_->flag = id2; return 0; } struct lset_node *temp = ((void *)0), *unbalanced = ((void *)0); _Bool is_root = node->parent == ((void *)0); if (node->left == ((void *)0) && node->right == ((void *)0)) { if (is_root) _set_->root = ((void *)0); else { unbalanced = node->parent; if (node->parent->right == node) node->parent->right = ((void *)0); else node->parent->left = ((void *)0); } _set_->alloc->free(node); } else if (node->left == ((void *)0)) { if (is_root) { _set_->root = node->right; _set_->root->parent = ((void *)0); } else { unbalanced = node->parent; node->right->parent = node->parent; if (node->parent->right == node) node->parent->right = node->right; else node->parent->left = node->right; } _set_->alloc->free(node); } else if (node->right == ((void *)0)) { if (is_root) { _set_->root = node->left; _set_->root->parent = ((void *)0); } else { unbalanced = node->parent; node->left->parent = node->parent; if (node->parent->right == node) node->parent->right = node->left; else node->parent->left = node->left; } _set_->alloc->free(node); } else { temp = node->right; while (temp->left != ((void *)0)) temp = temp->left; long temp_value = temp->value; unbalanced = temp->parent; if (temp->left == ((void *)0) && temp->right == ((void *)0)) { if (temp->parent->right == temp) temp->parent->right = ((void *)0); else temp->parent->left = ((void *)0); } else if (temp->left == ((void *)0)) { temp->right->parent = temp->parent; if (temp->parent->right == temp) temp->parent->right = temp->right; else temp->parent->left = temp->right; } else if (temp->right == ((void *)0)) { temp->left->parent = temp->parent; if (temp->parent->right == temp) temp->parent->right = temp->left; else temp->parent->left = temp->left; } _set_->alloc->free(temp); node->value = temp_value; } if (unbalanced != ((void *)0)) id18(_set_, unbalanced); if (_set_->count == 0) _set_->root = ((void *)0); _set_->count--; _set_->flag = id78; if ((_set_)->callbacks && (_set_)->callbacks->delete) (_set_)->callbacks->delete();; return 1; } _Bool ls_max(struct lset * _set_, long * value) { if (ls_empty(_set_)) { _set_->flag = id63; return 0; } struct lset_node *scan = _set_->root; while (scan->right != ((void *)0)) scan = scan->right; if (value) *value = scan->value; _set_->flag = id78; if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return 1; } _Bool ls_min(struct lset * _set_, long * value) { if (ls_empty(_set_)) { _set_->flag = id63; return 0; } struct lset_node *scan = _set_->root; while (scan->left != ((void *)0)) scan = scan->left; if (value) *value = scan->value; _set_->flag = id78; if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return 1; } _Bool ls_contains(struct lset * _set_, long value) { _Bool result = id81(_set_, value) != ((void *)0); if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return result; } _Bool ls_empty(struct lset * _set_) { return _set_->count == 0; } size_t ls_count(struct lset * _set_) { return _set_->count; } int ls_flag(struct lset * _set_) { return _set_->flag; } struct lset *id23(struct lset * _set_) { struct lset *result = id58(_set_->f_val, _set_->alloc, ((void *)0)); if (!result) { _set_->flag = id26; return ((void *)0); } (result)->callbacks = _set_->callbacks; if (!ls_empty(_set_)) { struct lset_iter iter = id59(_set_); for (; !id11(&iter); id25(&iter)) { if (_set_->f_val->cpy) ls_insert (result, _set_->f_val->cpy(id66(&iter))); else ls_insert(result, id66(&iter)); } } _set_->flag = id78; return result; } _Bool ls_equals(struct lset * id69, struct lset * id15) { id69->flag = id78; id15->flag = id78; if (id69->count != id15->count) return 0; struct lset_iter iter = id59(id69); for (; !id11(&iter); id25(&iter)) { if (id81(id15, id66(&iter)) == ((void *)0)) return 0; } return 1; } static struct lset_node * id42(struct lset * _set_, long value) { struct lset_node *node = _set_->alloc->malloc(sizeof(struct lset_node)); if (!node) return ((void *)0); node->value = value; node->right = ((void *)0); node->left = ((void *)0); node->parent = ((void *)0); node->height = 0; return node; } static struct lset_node * id81(struct lset * _set_, long value) { struct lset_node *scan = _set_->root; while (scan != ((void *)0)) { if (_set_->f_val->cmp(scan->value, value) > 0) scan = scan->left; else if (_set_->f_val->cmp(scan->value, value) < 0) scan = scan->right; else return scan; } return ((void *)0); } static unsigned char id65(struct lset_node * node) { if (node == ((void *)0)) return 0; return node->height; } static unsigned char id52(struct lset_node * node) { if (node == ((void *)0)) return 0; unsigned char h_l = id65(node->left); unsigned char h_r = id65(node->right); return 1 + (h_l > h_r ? h_l : h_r); } static void id20(struct lset_node * *Z) { struct lset_node *root = *Z; struct lset_node *new_root = root->left; if (root->parent != ((void *)0)) { if (root->parent->left == root) root->parent->left = new_root; else root->parent->right = new_root; } new_root->parent = root->parent; root->parent = new_root; root->left = new_root->right; if (root->left) root->left->parent = root; new_root->right = root; root->height = id52(root); new_root->height = id52(new_root); *Z = new_root; } static void id21(struct lset_node * *Z) { struct lset_node *root = *Z; struct lset_node *new_root = root->right; if (root->parent != ((void *)0)) { if (root->parent->right == root) root->parent->right = new_root; else root->parent->left = new_root; } new_root->parent = root->parent; root->parent = new_root; root->right = new_root->left; if (root->right) root->right->parent = root; new_root->left = root; root->height = id52(root); new_root->height = id52(new_root); *Z = new_root; } static void id18(struct lset * _set_, struct lset_node * node) { struct lset_node *scan = node, *child = ((void *)0); int balance; _Bool is_root = 0; while (scan != ((void *)0)) { if (scan->parent == ((void *)0)) is_root = 1; scan->height = id52(scan); balance = id65(scan->right) - id65(scan->left); if (balance >= 2) { child = scan->right; if (id65(child->right) < id65(child->left)) id20(&(scan->right)); id21(&scan); } else if (balance <= -2) { child = scan->left; if (id65(child->left) < id65(child->right)) id21(&(scan->left)); id20(&scan); } if (is_root) { _set_->root = scan; is_root = 0; } scan = scan->parent; } } struct lset_iter id59(struct lset * target) { struct lset_iter iter; iter.target = target; iter.cursor = target->root; iter.first = ((void *)0); iter.last = ((void *)0); iter.index = 0; iter.start = 1; iter.end = ls_empty(target); if (!ls_empty(target)) { while (iter.cursor->left != ((void *)0)) iter.cursor = iter.cursor->left; iter.first = iter.cursor; iter.last = target->root; while (iter.last->right != ((void *)0)) iter.last = iter.last->right; } return iter; } struct lset_iter id80(struct lset * target) { struct lset_iter iter; iter.target = target; iter.cursor = target->root; iter.first = ((void *)0); iter.last = ((void *)0); iter.index = 0; iter.start = ls_empty(target); iter.end = 1; if (!ls_empty(target)) { while (iter.cursor->right != ((void *)0)) iter.cursor = iter.cursor->right; iter.last = iter.cursor; iter.first = target->root; while (iter.first->left != ((void *)0)) iter.first = iter.first->left; iter.index = target->count - 1; } return iter; } _Bool id35(struct lset_iter * iter) { return ls_empty(iter->target) || iter->start; } _Bool id11(struct lset_iter * iter) { return ls_empty(iter->target) || iter->end; } _Bool id54(struct lset_iter * iter) { if (!ls_empty(iter->target)) { iter->index = 0; iter->start = 1; iter->end = ls_empty(iter->target); iter->cursor = iter->first; return 1; } return 0; } _Bool id37(struct lset_iter * iter) { if (!ls_empty(iter->target)) { iter->index = iter->target->count - 1; iter->start = ls_empty(iter->target); iter->end = 1; iter->cursor = iter->last; return 1; } return 0; } _Bool id25(struct lset_iter * iter) { if (iter->end) return 0; if (iter->cursor == iter->last) { iter->end = 1; return 0; } iter->start = ls_empty(iter->target); if (iter->cursor->right != ((void *)0)) { iter->cursor = iter->cursor->right; while (iter->cursor->left != ((void *)0)) iter->cursor = iter->cursor->left; iter->index++; return 1; } while (1) { if (iter->cursor->parent->left == iter->cursor) { iter->cursor = iter->cursor->parent; iter->index++; return 1; } iter->cursor = iter->cursor->parent; } } _Bool id13(struct lset_iter * iter) { if (iter->start) return 0; if (iter->cursor == iter->first) { iter->start = 1; return 0; } iter->end = ls_empty(iter->target); if (iter->cursor->left != ((void *)0)) { iter->cursor = iter->cursor->left; while (iter->cursor->right != ((void *)0)) iter->cursor = iter->cursor->right; iter->index--; return 1; } while (1) { if (iter->cursor->parent->right == iter->cursor) { iter->cursor = iter->cursor->parent; iter->index--; return 1; } iter->cursor = iter->cursor->parent; } } _Bool id74(struct lset_iter * iter, size_t steps) { if (iter->end) return 0; if (iter->cursor == iter->last) { iter->end = 1; return 0; } if (steps == 0 || iter->index + steps >= iter->target->count) return 0; for (size_t i = 0; i < steps; i++) id25(iter); return 1; } _Bool id71(struct lset_iter * iter, size_t steps) { if (iter->start) return 0; if (iter->cursor == iter->first) { iter->start = 1; return 0; } if (steps == 0 || iter->index < steps) return 0; for (size_t i = 0; i < steps; i++) id13(iter); return 1; } _Bool id72(struct lset_iter * iter, size_t index) { if (index >= iter->target->count) return 0; if (iter->index > index) return id71(iter, iter->index - index); else if (iter->index < index) return id74(iter, index - iter->index); return 1; } long id66(struct lset_iter * iter) { if (ls_empty(iter->target)) return (long){ 0 }; return iter->cursor->value; } size_t id50(struct lset_iter * iter) { return iter->index; } struct lset *ls_union(struct lset * id69, struct lset * id15) { struct lset *id55 = id58(id69->f_val, id69->alloc, ((void *)0)); if (!id55) return ((void *)0); struct lset_iter iter1 = id59(id69); struct lset_iter iter2 = id59(id15); for (; !id11(&iter1); id25(&iter1)) { ls_insert(id55, id66(&iter1)); } for (; !id11(&iter2); id25(&iter2)) { ls_insert(id55, id66(&iter2)); } (id55)->callbacks = id69->callbacks; return id55; } struct lset *id3(struct lset * id69, struct lset * id15) { struct lset *id55 = id58(id69->f_val, id69->alloc, ((void *)0)); if (!id55) return ((void *)0); struct lset *id7 = id69->count < id15->count ? id69 : id15; struct lset *id44 = id7 == id69 ? id15 : id69; struct lset_iter iter = id59(id7); for (; !id11(&iter); id25(&iter)) { long value = id66(&iter); if (id81(id44, value) != ((void *)0)) ls_insert(id55, value); } (id55)->callbacks = id69->callbacks; return id55; } struct lset *ls_difference(struct lset * id69, struct lset * id15) { struct lset *id55 = id58(id69->f_val, id69->alloc, ((void *)0)); if (!id55) return ((void *)0); struct lset_iter iter = id59(id69); for (; !id11(&iter); id25(&iter)) { long value = id66(&iter); if (id81(id15, value) == ((void *)0)) ls_insert(id55, value); } (id55)->callbacks = id69->callbacks; return id55; } struct lset *id48(struct lset * id69, struct lset * id15) { struct lset *id55 = id58(id69->f_val, id69->alloc, ((void *)0)); if (!id55) return ((void *)0); struct lset_iter iter1 = id59(id69); struct lset_iter iter2 = id59(id15); for (; !id11(&iter1); id25(&iter1)) { long value = id66(&iter1); if (id81(id15, value) == ((void *)0)) ls_insert(id55, value); } for (; !id11(&iter2); id25(&iter2)) { long value = id66(&iter2); if (id81(id69, value) == ((void *)0)) ls_insert(id55, value); } (id55)->callbacks = id69->callbacks; return id55; } _Bool id64(struct lset * id69, struct lset * id15) { if (id69->count > id15->count) return 0; if (ls_empty(id69)) return 1; struct lset_iter iter = id59(id69); for (; !id11(&iter); id25(&iter)) { long value = id66(&iter); if (id81(id15, value) == ((void *)0)) return 0; } return 1; } _Bool id32(struct lset * id69, struct lset * id15) { return id64(id15, id69); } _Bool id67(struct lset * id69, struct lset * id15) { if (id69->count >= id15->count) return 0; if (ls_empty(id69)) { if (!ls_empty(id15)) return 1; else return 0; } struct lset_iter iter = id59(id69); for (; !id11(&iter); id25(&iter)) { long value = id66(&iter); if (id81(id15, value) == ((void *)0)) return 0; } return 1; } _Bool id4(struct lset * id69, struct lset * id15) { return id67(id15, id69); } _Bool id62(struct lset * id69, struct lset * id15) { if (ls_empty(id69)) return 1; struct lset_iter iter = id59(id69); for (; !id11(&iter); id25(&iter)) { long value = id66(&iter); if (id81(id15, value) != ((void *)0)) return 0; } return 1; } _Bool id6(struct lset * _set_, FILE * fptr) { struct lset *s_ = _set_; return 0 <= fprintf(fptr, "struct %s<%s> " "at %p { " "root:%p, " "count:%" "l" "u" ", " "flag:%d, " "f_val:%p, " "alloc:%p, " "callbacks:%p }", "lset", "long", s_, s_->root, s_->count, s_->flag, s_->f_val, s_->alloc, (s_)->callbacks); } _Bool ls_print(struct lset * _set_, FILE * fptr, const char *start, const char *separator, const char *end) { fprintf(fptr, "%s", start); struct lset_node *root = _set_->root; _Bool left_done = 0; size_t i = 0; while (root) { if (!left_done) { while (root->left) root = root->left; } if (!_set_->f_val->str(fptr, root->value)) return 0; if (++i < _set_->count) fprintf(fptr, "%s", separator); left_done = 1; if (root->right) { left_done = 0; root = root->right; } else if (root->parent) { while (root->parent && root == root->parent->right) root = root->parent; if (!root->parent) break; root = root->parent; } else break; } fprintf(fptr, "%s", end); return 1; }
struct fset { struct fset_node * root; size_t count; int flag; struct fset_fval * f_val; struct cmc_alloc_node *alloc; struct cmc_callbacks *callbacks; }; struct fset_node { struct fragment value; unsigned char height; struct fset_node * right; struct fset_node * left; struct fset_node * parent; }; struct fset_fval { int (*cmp)(struct fragment, struct fragment); struct fragment (*cpy)(struct fragment); _Bool (*str)(FILE *, struct fragment); void (*free)(struct fragment); size_t (*hash)(struct fragment); int (*pri)(struct fragment, struct fragment); }; struct fset *fs_new(struct fset_fval * f_val); struct fset *id1(struct fset_fval * f_val, struct cmc_alloc_node * alloc, struct cmc_callbacks * callbacks); void fs_clear(struct fset * _set_); void fs_free(struct fset * _set_); _Bool fs_insert(struct fset * _set_, struct fragment value); _Bool fs_remove(struct fset * _set_, struct fragment value); _Bool fs_max(struct fset * _set_, struct fragment * value); _Bool fs_min(struct fset * _set_, struct fragment * value); _Bool fs_contains(struct fset * _set_, struct fragment value); _Bool fs_empty(struct fset * _set_); size_t fs_count(struct fset * _set_); int fs_flag(struct fset * _set_); struct fset *id12(struct fset * _set_); _Bool fs_equals(struct fset * id69, struct fset * id15); struct fset_iter { struct fset *target; struct fset_node * cursor; struct fset_node * first; struct fset_node * last; size_t index; _Bool start; _Bool end; }; struct fset_iter id27(struct fset * target); struct fset_iter id56(struct fset * target); _Bool id31(struct fset_iter * iter); _Bool id45(struct fset_iter * iter); _Bool id40(struct fset_iter * iter); _Bool id49(struct fset_iter * iter); _Bool id70(struct fset_iter * iter); _Bool id76(struct fset_iter * iter); _Bool id28(struct fset_iter * iter, size_t steps); _Bool id43(struct fset_iter * iter, size_t steps); _Bool id38(struct fset_iter * iter, size_t index); struct fragment id77(struct fset_iter * iter); size_t id30(struct fset_iter * iter); struct fset *fs_union(struct fset * id69, struct fset * id15); struct fset *id68(struct fset * id69, struct fset * id15); struct fset *fs_difference(struct fset * id69, struct fset * id15); struct fset *id36(struct fset * id69, struct fset * id15); _Bool id22(struct fset * id69, struct fset * id15); _Bool id79(struct fset * id69, struct fset * id15); _Bool id61(struct fset * id69, struct fset * id15); _Bool id5(struct fset * id69, struct fset * id15); _Bool id9(struct fset * id69, struct fset * id15); _Bool id73(struct fset * _set_, FILE * fptr); _Bool fs_print(struct fset * _set_, FILE * fptr, const char *start, const char *separator, const char *end); static struct fset_node * id33(struct fset * _set_, struct fragment value); static struct fset_node * id53(struct fset * _set_, struct fragment value); static unsigned char id39(struct fset_node * node); static unsigned char id46(struct fset_node * node); static void id60(struct fset_node * *Z); static void id57(struct fset_node * *Z); static void id17(struct fset * _set_, struct fset_node * node); struct fset *fs_new(struct fset_fval * f_val) { return id1(f_val, ((void *)0), ((void *)0)); } struct fset *id1(struct fset_fval * f_val, struct cmc_alloc_node * alloc, struct cmc_callbacks * callbacks) { ; if (!f_val) return ((void *)0); if (!alloc) alloc = &id10; struct fset *_set_ = alloc->malloc(sizeof(struct fset)); if (!_set_) return ((void *)0); _set_->count = 0; _set_->root = ((void *)0); _set_->flag = id78; _set_->f_val = f_val; _set_->alloc = alloc; (_set_)->callbacks = callbacks; return _set_; } void fs_clear(struct fset * _set_) { struct fset_node *scan = _set_->root; struct fset_node *up = ((void *)0); while (scan != ((void *)0)) { if (scan->left != ((void *)0)) { struct fset_node *left = scan->left; scan->left = up; up = scan; scan = left; } else if (scan->right != ((void *)0)) { struct fset_node *right = scan->right; scan->left = up; scan->right = ((void *)0); up = scan; scan = right; } else { if (up == ((void *)0)) { if (_set_->f_val->free) _set_->f_val->free(scan->value); _set_->alloc->free(scan); scan = ((void *)0); } while (up != ((void *)0)) { if (_set_->f_val->free) _set_->f_val->free(scan->value); _set_->alloc->free(scan); if (up->right != ((void *)0)) { scan = up->right; up->right = ((void *)0); break; } else { scan = up; up = up->left; } } } } _set_->count = 0; _set_->root = ((void *)0); _set_->flag = id78; } void fs_free(struct fset * _set_) { fs_clear(_set_); _set_->alloc->free(_set_); } _Bool fs_insert(struct fset * _set_, struct fragment value) { if (fs_empty(_set_)) { _set_->root = id33(_set_, value); if (!_set_->root) { _set_->flag = id41; return 0; } } else { struct fset_node *scan = _set_->root; struct fset_node *parent = scan; while (scan != ((void *)0)) { parent = scan; if (_set_->f_val->cmp(scan->value, value) > 0) scan = scan->left; else if (_set_->f_val->cmp(scan->value, value) < 0) scan = scan->right; else { _set_->flag = id19; return 0; } } struct fset_node * node; if (_set_->f_val->cmp(parent->value, value) > 0) { parent->left = id33(_set_, value); if (!parent->left) { _set_->flag = id41; return 0; } parent->left->parent = parent; node = parent->left; } else { parent->right = id33(_set_, value); if (!parent->right) { _set_->flag = id41; return 0; } parent->right->parent = parent; node = parent->right; } id17(_set_, node); } _set_->count++; _set_->flag = id78; if ((_set_)->callbacks && (_set_)->callbacks->create) (_set_)->callbacks->create();; return 1; } _Bool fs_remove(struct fset * _set_, struct fragment value) { if (fs_empty(_set_)) { _set_->flag = id63; return 0; } struct fset_node *node = id53(_set_, value); if (!node) { _set_->flag = id2; return 0; } struct fset_node *temp = ((void *)0), *unbalanced = ((void *)0); _Bool is_root = node->parent == ((void *)0); if (node->left == ((void *)0) && node->right == ((void *)0)) { if (is_root) _set_->root = ((void *)0); else { unbalanced = node->parent; if (node->parent->right == node) node->parent->right = ((void *)0); else node->parent->left = ((void *)0); } _set_->alloc->free(node); } else if (node->left == ((void *)0)) { if (is_root) { _set_->root = node->right; _set_->root->parent = ((void *)0); } else { unbalanced = node->parent; node->right->parent = node->parent; if (node->parent->right == node) node->parent->right = node->right; else node->parent->left = node->right; } _set_->alloc->free(node); } else if (node->right == ((void *)0)) { if (is_root) { _set_->root = node->left; _set_->root->parent = ((void *)0); } else { unbalanced = node->parent; node->left->parent = node->parent; if (node->parent->right == node) node->parent->right = node->left; else node->parent->left = node->left; } _set_->alloc->free(node); } else { temp = node->right; while (temp->left != ((void *)0)) temp = temp->left; struct fragment temp_value = temp->value; unbalanced = temp->parent; if (temp->left == ((void *)0) && temp->right == ((void *)0)) { if (temp->parent->right == temp) temp->parent->right = ((void *)0); else temp->parent->left = ((void *)0); } else if (temp->left == ((void *)0)) { temp->right->parent = temp->parent; if (temp->parent->right == temp) temp->parent->right = temp->right; else temp->parent->left = temp->right; } else if (temp->right == ((void *)0)) { temp->left->parent = temp->parent; if (temp->parent->right == temp) temp->parent->right = temp->left; else temp->parent->left = temp->left; } _set_->alloc->free(temp); node->value = temp_value; } if (unbalanced != ((void *)0)) id17(_set_, unbalanced); if (_set_->count == 0) _set_->root = ((void *)0); _set_->count--; _set_->flag = id78; if ((_set_)->callbacks && (_set_)->callbacks->delete) (_set_)->callbacks->delete();; return 1; } _Bool fs_max(struct fset * _set_, struct fragment * value) { if (fs_empty(_set_)) { _set_->flag = id63; return 0; } struct fset_node *scan = _set_->root; while (scan->right != ((void *)0)) scan = scan->right; if (value) *value = scan->value; _set_->flag = id78; if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return 1; } _Bool fs_min(struct fset * _set_, struct fragment * value) { if (fs_empty(_set_)) { _set_->flag = id63; return 0; } struct fset_node *scan = _set_->root; while (scan->left != ((void *)0)) scan = scan->left; if (value) *value = scan->value; _set_->flag = id78; if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return 1; } _Bool fs_contains(struct fset * _set_, struct fragment value) { _Bool result = id53(_set_, value) != ((void *)0); if ((_set_)->callbacks && (_set_)->callbacks->read) (_set_)->callbacks->read();; return result; } _Bool fs_empty(struct fset * _set_) { return _set_->count == 0; } size_t fs_count(struct fset * _set_) { return _set_->count; } int fs_flag(struct fset * _set_) { return _set_->flag; } struct fset *id12(struct fset * _set_) { struct fset *result = id1(_set_->f_val, _set_->alloc, ((void *)0)); if (!result) { _set_->flag = id26; return ((void *)0); } (result)->callbacks = _set_->callbacks; if (!fs_empty(_set_)) { struct fset_iter iter = id27(_set_); for (; !id45(&iter); id70(&iter)) { if (_set_->f_val->cpy) fs_insert (result, _set_->f_val->cpy(id77(&iter))); else fs_insert(result, id77(&iter)); } } _set_->flag = id78; return result; } _Bool fs_equals(struct fset * id69, struct fset * id15) { id69->flag = id78; id15->flag = id78; if (id69->count != id15->count) return 0; struct fset_iter iter = id27(id69); for (; !id45(&iter); id70(&iter)) { if (id53(id15, id77(&iter)) == ((void *)0)) return 0; } return 1; } static struct fset_node * id33(struct fset * _set_, struct fragment value) { struct fset_node *node = _set_->alloc->malloc(sizeof(struct fset_node)); if (!node) return ((void *)0); node->value = value; node->right = ((void *)0); node->left = ((void *)0); node->parent = ((void *)0); node->height = 0; return node; } static struct fset_node * id53(struct fset * _set_, struct fragment value) { struct fset_node *scan = _set_->root; while (scan != ((void *)0)) { if (_set_->f_val->cmp(scan->value, value) > 0) scan = scan->left; else if (_set_->f_val->cmp(scan->value, value) < 0) scan = scan->right; else return scan; } return ((void *)0); } static unsigned char id39(struct fset_node * node) { if (node == ((void *)0)) return 0; return node->height; } static unsigned char id46(struct fset_node * node) { if (node == ((void *)0)) return 0; unsigned char h_l = id39(node->left); unsigned char h_r = id39(node->right); return 1 + (h_l > h_r ? h_l : h_r); } static void id60(struct fset_node * *Z) { struct fset_node *root = *Z; struct fset_node *new_root = root->left; if (root->parent != ((void *)0)) { if (root->parent->left == root) root->parent->left = new_root; else root->parent->right = new_root; } new_root->parent = root->parent; root->parent = new_root; root->left = new_root->right; if (root->left) root->left->parent = root; new_root->right = root; root->height = id46(root); new_root->height = id46(new_root); *Z = new_root; } static void id57(struct fset_node * *Z) { struct fset_node *root = *Z; struct fset_node *new_root = root->right; if (root->parent != ((void *)0)) { if (root->parent->right == root) root->parent->right = new_root; else root->parent->left = new_root; } new_root->parent = root->parent; root->parent = new_root; root->right = new_root->left; if (root->right) root->right->parent = root; new_root->left = root; root->height = id46(root); new_root->height = id46(new_root); *Z = new_root; } static void id17(struct fset * _set_, struct fset_node * node) { struct fset_node *scan = node, *child = ((void *)0); int balance; _Bool is_root = 0; while (scan != ((void *)0)) { if (scan->parent == ((void *)0)) is_root = 1; scan->height = id46(scan); balance = id39(scan->right) - id39(scan->left); if (balance >= 2) { child = scan->right; if (id39(child->right) < id39(child->left)) id60(&(scan->right)); id57(&scan); } else if (balance <= -2) { child = scan->left; if (id39(child->left) < id39(child->right)) id57(&(scan->left)); id60(&scan); } if (is_root) { _set_->root = scan; is_root = 0; } scan = scan->parent; } } struct fset_iter id27(struct fset * target) { struct fset_iter iter; iter.target = target; iter.cursor = target->root; iter.first = ((void *)0); iter.last = ((void *)0); iter.index = 0; iter.start = 1; iter.end = fs_empty(target); if (!fs_empty(target)) { while (iter.cursor->left != ((void *)0)) iter.cursor = iter.cursor->left; iter.first = iter.cursor; iter.last = target->root; while (iter.last->right != ((void *)0)) iter.last = iter.last->right; } return iter; } struct fset_iter id56(struct fset * target) { struct fset_iter iter; iter.target = target; iter.cursor = target->root; iter.first = ((void *)0); iter.last = ((void *)0); iter.index = 0; iter.start = fs_empty(target); iter.end = 1; if (!fs_empty(target)) { while (iter.cursor->right != ((void *)0)) iter.cursor = iter.cursor->right; iter.last = iter.cursor; iter.first = target->root; while (iter.first->left != ((void *)0)) iter.first = iter.first->left; iter.index = target->count - 1; } return iter; } _Bool id31(struct fset_iter * iter) { return fs_empty(iter->target) || iter->start; } _Bool id45(struct fset_iter * iter) { return fs_empty(iter->target) || iter->end; } _Bool id40(struct fset_iter * iter) { if (!fs_empty(iter->target)) { iter->index = 0; iter->start = 1; iter->end = fs_empty(iter->target); iter->cursor = iter->first; return 1; } return 0; } _Bool id49(struct fset_iter * iter) { if (!fs_empty(iter->target)) { iter->index = iter->target->count - 1; iter->start = fs_empty(iter->target); iter->end = 1; iter->cursor = iter->last; return 1; } return 0; } _Bool id70(struct fset_iter * iter) { if (iter->end) return 0; if (iter->cursor == iter->last) { iter->end = 1; return 0; } iter->start = fs_empty(iter->target); if (iter->cursor->right != ((void *)0)) { iter->cursor = iter->cursor->right; while (iter->cursor->left != ((void *)0)) iter->cursor = iter->cursor->left; iter->index++; return 1; } while (1) { if (iter->cursor->parent->left == iter->cursor) { iter->cursor = iter->cursor->parent; iter->index++; return 1; } iter->cursor = iter->cursor->parent; } } _Bool id76(struct fset_iter * iter) { if (iter->start) return 0; if (iter->cursor == iter->first) { iter->start = 1; return 0; } iter->end = fs_empty(iter->target); if (iter->cursor->left != ((void *)0)) { iter->cursor = iter->cursor->left; while (iter->cursor->right != ((void *)0)) iter->cursor = iter->cursor->right; iter->index--; return 1; } while (1) { if (iter->cursor->parent->right == iter->cursor) { iter->cursor = iter->cursor->parent; iter->index--; return 1; } iter->cursor = iter->cursor->parent; } } _Bool id28(struct fset_iter * iter, size_t steps) { if (iter->end) return 0; if (iter->cursor == iter->last) { iter->end = 1; return 0; } if (steps == 0 || iter->index + steps >= iter->target->count) return 0; for (size_t i = 0; i < steps; i++) id70(iter); return 1; } _Bool id43(struct fset_iter * iter, size_t steps) { if (iter->start) return 0; if (iter->cursor == iter->first) { iter->start = 1; return 0; } if (steps == 0 || iter->index < steps) return 0; for (size_t i = 0; i < steps; i++) id76(iter); return 1; } _Bool id38(struct fset_iter * iter, size_t index) { if (index >= iter->target->count) return 0; if (iter->index > index) return id43(iter, iter->index - index); else if (iter->index < index) return id28(iter, index - iter->index); return 1; } struct fragment id77(struct fset_iter * iter) { if (fs_empty(iter->target)) return (struct fragment){ 0 }; return iter->cursor->value; } size_t id30(struct fset_iter * iter) { return iter->index; } struct fset *fs_union(struct fset * id69, struct fset * id15) { struct fset *id55 = id1(id69->f_val, id69->alloc, ((void *)0)); if (!id55) return ((void *)0); struct fset_iter iter1 = id27(id69); struct fset_iter iter2 = id27(id15); for (; !id45(&iter1); id70(&iter1)) { fs_insert(id55, id77(&iter1)); } for (; !id45(&iter2); id70(&iter2)) { fs_insert(id55, id77(&iter2)); } (id55)->callbacks = id69->callbacks; return id55; } struct fset *id68(struct fset * id69, struct fset * id15) { struct fset *id55 = id1(id69->f_val, id69->alloc, ((void *)0)); if (!id55) return ((void *)0); struct fset *id7 = id69->count < id15->count ? id69 : id15; struct fset *id44 = id7 == id69 ? id15 : id69; struct fset_iter iter = id27(id7); for (; !id45(&iter); id70(&iter)) { struct fragment value = id77(&iter); if (id53(id44, value) != ((void *)0)) fs_insert(id55, value); } (id55)->callbacks = id69->callbacks; return id55; } struct fset *fs_difference(struct fset * id69, struct fset * id15) { struct fset *id55 = id1(id69->f_val, id69->alloc, ((void *)0)); if (!id55) return ((void *)0); struct fset_iter iter = id27(id69); for (; !id45(&iter); id70(&iter)) { struct fragment value = id77(&iter); if (id53(id15, value) == ((void *)0)) fs_insert(id55, value); } (id55)->callbacks = id69->callbacks; return id55; } struct fset *id36(struct fset * id69, struct fset * id15) { struct fset *id55 = id1(id69->f_val, id69->alloc, ((void *)0)); if (!id55) return ((void *)0); struct fset_iter iter1 = id27(id69); struct fset_iter iter2 = id27(id15); for (; !id45(&iter1); id70(&iter1)) { struct fragment value = id77(&iter1); if (id53(id15, value) == ((void *)0)) fs_insert(id55, value); } for (; !id45(&iter2); id70(&iter2)) { struct fragment value = id77(&iter2); if (id53(id69, value) == ((void *)0)) fs_insert(id55, value); } (id55)->callbacks = id69->callbacks; return id55; } _Bool id22(struct fset * id69, struct fset * id15) { if (id69->count > id15->count) return 0; if (fs_empty(id69)) return 1; struct fset_iter iter = id27(id69); for (; !id45(&iter); id70(&iter)) { struct fragment value = id77(&iter); if (id53(id15, value) == ((void *)0)) return 0; } return 1; } _Bool id79(struct fset * id69, struct fset * id15) { return id22(id15, id69); } _Bool id61(struct fset * id69, struct fset * id15) { if (id69->count >= id15->count) return 0; if (fs_empty(id69)) { if (!fs_empty(id15)) return 1; else return 0; } struct fset_iter iter = id27(id69); for (; !id45(&iter); id70(&iter)) { struct fragment value = id77(&iter); if (id53(id15, value) == ((void *)0)) return 0; } return 1; } _Bool id5(struct fset * id69, struct fset * id15) { return id61(id15, id69); } _Bool id9(struct fset * id69, struct fset * id15) { if (fs_empty(id69)) return 1; struct fset_iter iter = id27(id69); for (; !id45(&iter); id70(&iter)) { struct fragment value = id77(&iter); if (id53(id15, value) != ((void *)0)) return 0; } return 1; } _Bool id73(struct fset * _set_, FILE * fptr) { struct fset *s_ = _set_; return 0 <= fprintf(fptr, "struct %s<%s> " "at %p { " "root:%p, " "count:%" "l" "u" ", " "flag:%d, " "f_val:%p, " "alloc:%p, " "callbacks:%p }", "fset", "struct fragment", s_, s_->root, s_->count, s_->flag, s_->f_val, s_->alloc, (s_)->callbacks); } _Bool fs_print(struct fset * _set_, FILE * fptr, const char *start, const char *separator, const char *end) { fprintf(fptr, "%s", start); struct fset_node *root = _set_->root; _Bool left_done = 0; size_t i = 0; while (root) { if (!left_done) { while (root->left) root = root->left; } if (!_set_->f_val->str(fptr, root->value)) return 0; if (++i < _set_->count) fprintf(fptr, "%s", separator); left_done = 1; if (root->right) { left_done = 0; root = root->right; } else if (root->parent) { while (root->parent && root == root->parent->right) root = root->parent; if (!root->parent) break; root = root->parent; } else break; } fprintf(fptr, "%s", end); return 1; } ;

long moves(struct lset *piles, struct fset *fragments) {
	if (ls_count(piles) <= 2) {
		return 0;
	}
	long id34, id8;
	ls_max(piles, &id34);
	ls_min(piles, &id8);
	struct fragment max_frag;
	fs_max(fragments, &max_frag);
	return id34 - id8 - max_frag.len;
}

static struct lset_node* id47(struct lset_node * nd, long value) {
    while (nd != NULL) { 
        if (nd->value > value) {
            nd = nd->left;
        } else if (nd->value < value) {
            nd = nd->right;
        }	else {
            break;
        }
    }
    return nd;
}

static struct lset_node* id0(struct lset_node *nd, long value) {
	if (nd == NULL || nd->value == value) {
		return nd;
	}
	if (nd->value < value) {
		return id0(nd->right, value);
	}
	struct lset_node *gte = id0(nd->left, value);
	return (gte && gte->value >= value)? gte: nd;
}

static struct lset_node* id14(struct lset_node* nd) {
	if (nd->left != NULL) {
		return id14(nd->left);
	}
	return nd;
}

static struct lset_node* id16(struct lset_node* nd) {
	if (nd->right != NULL) {
		return id16(nd->right);
	}
	return nd;
}
static struct lset_node* id51(struct lset_node* nd) {
	if (nd->left != NULL) {
		return id16(nd->left);
	}
	struct lset_node* par = nd->parent;
	while (par != NULL && nd == par->left) {
		nd = par;
		par = par->parent;
	}
	return par;
}

static struct lset_node* id75(struct lset_node* nd) {
	if (nd->right != NULL) {
		return id14(nd->right);
	}
	struct lset_node* par = nd->parent;
	while (par != NULL && nd == par->right) {
		nd = par;
		par = par->parent;
	}
	return par;
}

int main() {
	struct lset *piles = ls_new(&(struct lset_fval){
		.cmp = id29
	});
	int n, q;
	scanf("%d%d", &n, &q);
	for (int i = 0; i < n; ++i) {
		long pile;
		scanf("%ld", &pile);
		ls_insert(piles, pile);
	}
	struct fset *fragments = fs_new(&(struct fset_fval){
		.cmp = fragment_compare
	});
	{
		long b, e;
		struct lset_iter it = id59(piles);
		for (;!id11(&it); id25(&it)) {
			if (id35(&it)) {
				b = id66(&it);
			} else {
				e = id66(&it);
				fs_insert(fragments, (struct fragment){e - b, b});
				b = e;
			}
		}
	}
	printf("%ld\n", moves(piles, fragments));
	for (int i = 0; i < q; ++i) {
		long t, x;
		scanf("%ld%ld", &t, &x);		
		if (t == 0) {
			if (ls_count(piles) > 1) {
				long id34, id8;
				ls_max(piles, &id34);
				ls_min(piles, &id8);
				struct lset_node *nd = id47(piles->root, x);			
				if (x == id8) {
					struct lset_node *nxt = id75(nd);
					fs_remove(fragments, (struct fragment){nxt->value - nd->value, nd->value});
				} else if (x == id34) {
					struct lset_node *prv = id51(nd);
					fs_remove(fragments, (struct fragment){nd->value - prv->value, prv->value});
				} else {
					struct lset_node *nxt = id75(nd);
					struct lset_node *prv = id51(nd);
					fs_remove(fragments, (struct fragment){nxt->value - nd->value, nd->value});
					fs_remove(fragments, (struct fragment){nd->value - prv->value, prv->value});
					fs_insert(fragments, (struct fragment){nxt->value - prv->value, prv->value});
				}
			}
			ls_remove(piles, x);
		} else {
			if (ls_count(piles) > 0) {
				long id34, id8;
				ls_max(piles, &id34);
				ls_min(piles, &id8);
				if (x < id8) {
					fs_insert(fragments, (struct fragment){id8 - x, x});
				} else if (id34 < x) {
					fs_insert(fragments, (struct fragment){x - id34, id34});
				} else {
					struct lset_node *nxt = id0(piles->root, x);
					struct lset_node *prv = id51(nxt);
					fs_insert(fragments, (struct fragment){nxt->value - x, x});
					fs_insert(fragments, (struct fragment){x - prv->value, prv->value});
					fs_remove(fragments, (struct fragment){nxt->value - prv->value, prv->value});
				}
			}
			ls_insert(piles, x);
		}
		printf("%ld\n", moves(piles, fragments));
	}
	ls_free(piles);
	fs_free(fragments);
	return 0;
}