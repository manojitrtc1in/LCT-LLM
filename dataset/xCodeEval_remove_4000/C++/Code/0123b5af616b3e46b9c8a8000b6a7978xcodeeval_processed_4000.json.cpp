





















using namespace std;

using namespace __gnu_pbds;
 




 





struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
 
    size_t operator()(uint64_t x) const {
        static const uint64_t id0 = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + id0);
    }
};
 




 








 






 




 






 






 





















inline lli powmod(lli base,lli exponent,lli mod=MOD)
{ 
	lli ans=1;
	while(exponent)
	{
		if(exponent&1) ans=(ans*base)%mod;
		base=(base*base)%mod;
		exponent>>=1;
	}
	return ans;
}






















































































































































































































































































































































































































































































































































































































	





























			







































































































































































































































































































































































































































































const lli M=5e5;

int main() 
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	lli a,b,c,d,e,q,h,i,j,k,m,n,n1,n2,n3;
	lli t,tt;
	lli mod=MOD, inf=id1;
	lli pr=998244353;

	srand(time(NULL));
	

	

	

	

	

	


	

	


	


	


	

	

	


	

	


	

	

	

	

	

	

	

	

	

	

	


	

	

	

	

	

	

	

	

	

	


	

	

	

	

	

	

	

	

	

	


	

	


	

	

	

	

	

	

	

	

	

	

	

	

	




	for(t=1,tt=1;tt<=t;tt++,newl)
	{

		cin>>n;
		lli ct=1;
		lli val=0;

		vi mp[M+5];

		map<lli,lli> dic;
		forl(i,0,n)
		{
			cin>>a;
			if(a==1)
			{
				cin>>a;
				mp[a].pb(val);
				val++;
			}
			else
			{
				cin>>a>>b;
				if(a==b) continue;
				if(sz(mp[a])>sz(mp[b]))
				{
					swap(mp[a],mp[b]);					
				}

				forl(j,0,sz(mp[a]))
				{
					mp[b].pb(mp[a][j]);
				}					
				mp[a].clear();
			}
		}

		lli ans[val+5];

		forl(i,0,M+5)
		{
			forl(j,0,sz(mp[i]))
			{
				ans[mp[i][j]]=i;
			}
		}

		pat(i,0,val,ans);




		


		


		


		

		

		

		

		


		

		


		


		





		


		


		

		

		

		

		


		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		


		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		


		

		

		

		

		

		



		

		


		

		

		

		

		


		


		

		

		

		


		

		

		

		

		

		

		


		

		

		


		


		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		



		

		

		

		

		

		

		

		

		

		

		

		


		

		


		

		

		

		

		

		

		


		

		

		

	}
	return 0;
}


















