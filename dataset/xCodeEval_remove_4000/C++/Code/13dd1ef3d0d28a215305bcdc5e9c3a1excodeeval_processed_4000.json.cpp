   




























































































using namespace std;
































typedef struct{ int sum,suf,pre,max;} Node;
int toint(const string &s) { stringstream ss; ss << s; int x; ss >> x; return x; }
const int MAXN = 2e5+100;
const int UP = 31;




const ll highest = 1e18;    




const double pi = acos(-1);
const double Phi =  1.618033988749894;
const int logn = 20;
const double root5 = 2.236067977;   
const ll inf64=1e16;
const int mod = 1e9+7;
const int ini = -1e9;

const int N = 2e5+10;
std::map<int, bool> vis;
std::map<int,int> par;
map<int,int> ct;
std::map<int, std::vector<int> > gr;
std::map<int, int>::iterator it;
int n;
void dfs(int u){
    if(vis[u])return;
    vis[u] = 1;
    for(auto x:gr[u]){
        if(!vis[x]){
            par[x] = u;
            dfs(x);
        }
    }
}
int main(){ 
    scanf("%d",&n);
    for(int i=0;i<n;++i){
        int u,v;
        scanf("%d%d",&u,&v);
        ct[u]++;
        ct[v]++;
        gr[u].pb(v);
        gr[v].pb(u);
        par[u] = 0;
        par[v] = 0;
        vis[u] = false;
        vis[v] = false;
    }
    int st = -1,en = -1;
    for(it = ct.begin();it != ct.end();++it){
        int ct = it->se;
        if(ct&1){
            if(st==-1){
                st = it->fi;
            }else if(en==-1){
                en = it->fi;
            }
        }
    }
    

    par[st] = st;
    dfs(st);
    if(vis[en]){
        std::vector<int> path;
        int x = en;
        while(x != par[x]){ 
            path.pb(x);
            x = par[x];
        }
        reverse(path.begin(),path.end());
        cout<<st<<" ";
        for(auto x:path){
            cout<<x<<" ";
        }
        cout<<"\n";
        return 0;
    }
    


    

    return 0;
}






















































































































































































































        












        








 



































        
































































































































































































































































































































































































































































